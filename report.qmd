---
title: "Polvices polvando polvivamente"
format:
   pdf:
       include-in-header:
           - text: |
                \usepackage{todonotes}
                \usepackage{graphicx}
                \usepackage{amsmath}
       documentclass: asaproc
       classoption: [11pt]
editor: source
cite-method: biblatex
bibliography: Polvices.bib
biblatexoptions: 
  - citestyle=authoryear
author:
  - name: "Alberto Rocha \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: true
  - name: "Ana Moreno \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: false
number-sections: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| eval: false
#| echo: false
tinytex::parse_install("report.log")
tinytex::tlmgr_update()


# https://cameronpatrick.com/post/2023/07/quarto-thesis-formatting/
```

```{r setup}
#| include: false

library(CatDyn)
library(RTMB)
library(optimx)
library(wesanderson)
library(tidyverse)
library(ggpattern)
library(xtable)
library(tmbstan)
library(shinystan)

source('scripts/custom_catdyn_fit.R')
source('scripts/custom_catdyn_bsd.R')
source('scripts/funcoes_catdyn.R')

load("data/df_effort_m_mbw_otb.Rdata")
load('data/mbw_model.Rdata')
load('data/chuva.rdata')

mod_aux = lm(df_effort$catch ~ df_effort$effort)

# Fix a couple of outliers

# df_effort =
#   vd %>%
#   group_by(year_sale, month_sale, IEMBARCA, PORTO) %>%
#   summarise(Power.Main.raw = mean(Power.Main, na.rm = T),
#             Power.main = trunc(Power.Main.raw/50) * 50,
#             catch_i = sum(QVENDA[EGRUPART == 'MIS_MIS']),
#             catch_i_otb = sum(QVENDA),
#             effort_i = n_distinct(IDATVEND[EGRUPART == 'MIS_MIS']),
#             effort_i_otb = n_distinct(IDATVEND))


df_effort = 
  df_effort %>% 
  # mutate(catch = case_when(year_sale == 2005 &
  #                            month_sale == '09' ~
  #                            effort * mod_aux$coefficients[2] +
  #                            mod_aux$coefficients[1],
  #                          T ~ catch),
  #        catch_otb = case_when(year_sale == 2005 &
  #                                month_sale == '09' ~
  #                                effort_otb * mod_aux$coefficients[2] +
  #                                mod_aux$coefficients[1],
  #                              T ~ catch_otb)) %>% 
  mutate(catch_otb = case_when(catch_otb == 0 ~ 0.1, 
                               T ~ catch_otb)
         # effort_otb = case_when(effort_otb  < 150 ~ mean(effort_otb),
         #                        T ~ effort_otb)
                                )
                                
cat_df = as.CatDynData(x=df_effort %>%
                         filter(as.numeric(
                           as.character(year_sale)) %in% c(2006:2020)),
                       step="month",
                       fleet.name="MIS+OTB-S",
                       coleff=6,
                       colcat=5,
                       colmbw=9,
                       unitseff="trips",
                       unitscat="kg",
                       unitsmbw="kg",
                       nmult="thou",
                       season.dates=c(as.Date("2006-01-01"),
                                      last_date_of_week(2020, 52)-1))

report_manual = function(p, method, dates,
                         distr, fleet.name, par.tmp,
                         opt_result){
  results2 = vector("list", length(method))
  names(results2) = method
  temp = attr(opt_result, "details")
  for (i in 1:length(method)) {
    results2[[i]]$Type <- p
    results2[[i]]$Dates <- dates
    names(results2[[i]]$Dates) <- c("ts.start",
                                    paste0('ts.', seq(1:p)),
                                    "ts.end")
    results2[[i]]$Distr <- distr
    par.names <- c("M", "N0", paste0('P', seq(1:p), ".", rep(fleet.name,p)),
                   paste(c("k.", "alpha.", "beta."), fleet.name, sep = ""))
    
    if (distr %in% c("negbin", "normal" ,
                     "lognormal",  "gamma",
                     "roblognormal", "gumbel")) {
      par.names <- c(par.names, paste("psi.", fleet.name, 
                                      sep = ""))
    }
    
    results2[[i]]$converg <- "FAIL"
    results2[[i]]$kkt <- NA
    results2[[i]]$AIC <- NA
    results2[[i]]$bt.par <- NA
    results2[[i]]$num.grads <- NA
    results2[[i]]$bt.stdev <- NA
    results2[[i]]$Cor <- matrix(NA, length(par.names), 
                                length(par.names))
    
    print("NAs in the Hessian?")
    print(any(is.na(temp[i,]$nhatend)))
    print("Heuristic check of condition")
    print(1/kappa(temp[i,]$nhatend) > 1e-15)
    
    if (length(temp[i, ]$ngatend) == length(par.names) & 
        !any(is.na(temp[i, ]$nhatend)) & 1/kappa(temp[i, 
        ]$nhatend) > 1e-15) {
      results2[[i]]$converg <- opt_result[i, sum(lengths(par.tmp)) + 
                                            5]
      results2[[i]]$kkt <- opt_result[i, (sum(lengths(par.tmp)) + 
                                            6):(sum(lengths(par.tmp)) + 7)]
      results2[[i]]$AIC <- 2 * sum(lengths(par.tmp)) + 2 * 
        opt_result[i, sum(lengths(par.tmp)) + 1]
      results2[[i]]$bt.par <- exp(opt_result[i, (1:sum(lengths(par.tmp)))])
      results2[[i]]$num.grads <- temp[i, ]$ngatend
      
      v <- matrix(0, length(par.names), length(par.names))
      
      if (distr %in% c("poisson",  "apnormal", "aplnormal")) {
        v <- deltamethod(
          g = lapply(paste0('~exp(x', 1:sum(lengths(par.tmp)), ')'), as.formula),
          mean = as.numeric(opt_result[i, 1:sum(lengths(par.tmp))]),
          cov = try(solve(temp[i, ]$nhatend)),
          ses = FALSE
        )
      }
      else {
        # consertar isto!!!
        v <- deltamethod(
          g = lapply(paste0('~exp(x', seq_along(sum(lengths(par.tmp))), ')'), as.formula),
          mean = as.numeric(opt_result[i, 1:sum(lengths(par.tmp))]),
          cov = try(solve(temp[i, ]$nhatend)),
          ses = FALSE
        )
      }
      results2[[i]]$bt.stdev <- sqrt(diag(v))
      results2[[i]]$Cor <- cor(v)
      names(results2[[i]]$num.grads) <- par.names
      names(results2[[i]]$bt.par) <- par.names
      names(results2[[i]]$bt.stdev) <- par.names
      colnames(results2[[i]]$Cor) <- par.names
      rownames(results2[[i]]$Cor) <- par.names 
    } else {print('convergencia e meio merdosa')}}
  return(results2)}


# report_manual_beta <- function(p, method, dates,
#                                distr, fleet.name, par.tmp,
#                                opt_result) {
#   
#   results2 <- vector("list", length(method))
#   names(results2) <- method
#   
#   # Try to get optimization details safely
#   temp <- attr(opt_result, "details")
#   if (is.null(temp)) temp <- list()
#   
#   # --- 1. Build parameter names dynamically ---
#   par.names <- unlist(lapply(names(par.tmp), function(nm) {
#     vals <- par.tmp[[nm]]
#     if (length(vals) == 1) return(nm)
#     paste0(nm, ".", seq_along(vals))
#   }))
#   np <- length(par.names)
#   
#   # --- 2. Match parameter names with opt_result columns ---
#   colnames_res <- colnames(opt_result)
#   par.cols <- which(colnames_res %in% par.names)
#   
#   if (length(par.cols) != np) {
#     warning("Number of matched parameters (", length(par.cols),
#             ") does not match expected (", np, ").")
#   }
#   
#   for (i in seq_along(method)) {
#     results2[[i]] <- list()
#     results2[[i]]$Type <- p
#     results2[[i]]$Dates <- dates
#     names(results2[[i]]$Dates) <- c("ts.start", paste0("ts.", seq_len(p)), "ts.end")
#     results2[[i]]$Distr <- distr
#     
#     # Initialize result slots
#     results2[[i]]$converg <- "FAIL"
#     results2[[i]]$kkt <- NA
#     results2[[i]]$AIC <- NA
#     results2[[i]]$bt.par <- rep(NA, np)
#     results2[[i]]$num.grads <- rep(NA, np)
#     results2[[i]]$bt.stdev <- rep(NA, np)
#     results2[[i]]$Cor <- matrix(NA, np, np)
#     
#     # --- 3. Extract parameter estimates ---
#     if (length(par.cols) > 0) {
#       theta_hat <- as.numeric(opt_result[i, par.cols, drop = TRUE])
#       names(theta_hat) <- par.names
#     } else {
#       warning("No parameter columns matched for method ", method[i])
#       next
#     }
#     
#     # --- 4. Pull diagnostic columns if they exist ---
#     converg <- opt_result[i, "convcode", drop = TRUE]
#     if (is.na(converg)) converg <- "UNK"
#     
#     results2[[i]]$converg <- converg
#     if ("kkt1" %in% colnames_res && "kkt2" %in% colnames_res)
#       results2[[i]]$kkt <- unlist(opt_result[i, c("kkt1", "kkt2")])
#     
#     if ("value" %in% colnames_res)
#       results2[[i]]$AIC <- 2 * np + 2 * as.numeric(opt_result[i, "value"])
#     
#     # --- 5. Back-transform parameters ---
#     results2[[i]]$bt.par <- exp(theta_hat)
#     
#     # --- 6. Try gradients and Hessian ---
#     ngat <- NULL
#     nhat <- NULL
#     if (length(temp) >= i && !is.null(temp[[i]]$ngatend))
#       ngat <- temp[[i]]$ngatend
#     if (length(temp) >= i && !is.null(temp[[i]]$nhatend))
#       nhat <- temp[[i]]$nhatend
#     
#     if (!is.null(ngat) && length(ngat) == np)
#       results2[[i]]$num.grads <- ngat
#     
#     # --- 7. Delta-method standard errors (if Hessian available) ---
#     if (!is.null(nhat) && all(dim(nhat) == c(np, np)) && !any(is.na(nhat))) {
#       cov.try <- try(solve(nhat), silent = TRUE)
#       if (!inherits(cov.try, "try-error")) {
#         v <- deltamethod(
#           g = lapply(paste0("~exp(x", seq_len(np), ")"), as.formula),
#           mean = theta_hat,
#           cov = cov.try,
#           ses = FALSE
#         )
#         results2[[i]]$bt.stdev <- sqrt(diag(v))
#         results2[[i]]$Cor <- cor(v)
#       } else {
#         warning("Hessian inversion failed for method ", method[i])
#       }
#     } else {
#       message("No valid Hessian for method ", method[i])
#     }
#     
#     # --- 8. Name all outputs ---
#     names(results2[[i]]$bt.par) <- par.names
#     names(results2[[i]]$num.grads) <- par.names
#     names(results2[[i]]$bt.stdev) <- par.names
#     rownames(results2[[i]]$Cor) <- par.names
#     colnames(results2[[i]]$Cor) <- par.names
#   }
#   
#   return(results2)
# }

report_manual_beta <- function(p, method, dates,
                               distr, fleet.name, par.tmp,
                               opt_result) {
  
  `%||%` <- function(x, y) if (!is.null(x)) x else y
  
  results2 <- vector("list", length(method))
  names(results2) <- method
  
  # --- Build dynamic parameter names ---
  par.names <- unlist(lapply(names(par.tmp), function(nm) {
    vals <- par.tmp[[nm]]
    if (length(vals) == 1) nm else paste0(nm, ".", seq_len(length(vals) - 1))
  }))
  par.names <- unique(c(gsub("\\.1$", "", par.names), par.names))
  
  par.cols <- which(colnames(opt_result) %in% par.names)
  np <- length(par.cols)
  if (np == 0) stop("No parameter columns matched in opt_result.")
  
  temp <- attr(opt_result, "details")
  if (is.null(temp)) stop("No details attribute found in opt_result — cannot extract Hessian.")
  
  for (i in seq_along(method)) {
    results2[[i]] <- list(
      Type = p,
      Dates = setNames(dates, c("ts.start", paste0("ts.", seq_len(p)), "ts.end")),
      Distr = distr,
      converg = "FAIL",
      kkt = NA,
      AIC = NA,
      bt.par = rep(NA, np),
      num.grads = rep(NA, np),
      bt.stdev = rep(NA, np),
      # Cor = matrix(0, np, np)
      Cor = matrix(NA, np, np)
    )
    
    # --- Extract coefficients ---
    theta_hat <- as.numeric(opt_result[i, par.cols])
    names(theta_hat) <- colnames(opt_result)[par.cols]
    results2[[i]]$bt.par <- exp(theta_hat)
    
    # --- Diagnostics ---
    if ("convcode" %in% names(opt_result))
      results2[[i]]$converg <- as.character(opt_result[i, "convcode"])
    if (all(c("kkt1", "kkt2") %in% names(opt_result)))
      results2[[i]]$kkt <- unlist(opt_result[i, c("kkt1", "kkt2")])
    if ("value" %in% names(opt_result))
      results2[[i]]$AIC <- 2 * np + 2 * as.numeric(opt_result[i, "value"])
    
    # --- Gradient ---
    grad.candidates <- c("ngatend", "grad", "gradient", "Grad")
    for (gc in grad.candidates) {
      if (gc %in% names(temp[[i]])) {
        results2[[i]]$num.grads <- temp[[i]][[gc]]
        break
      }
    }
    
    # --- Hessian ---
    nhat <- NULL
    hc <- NULL

    # Case 1: details is a list of lists (normal)
    if (length(temp) >= i && is.list(temp[[i]])) {
      hess.candidates <- c("nhatend", "Hess", "hess", "hessian", "Hessian")
      for (hc_try in hess.candidates) {
        if (hc_try %in% names(temp[[i]])) {
          nhat <- temp[[i]][[hc_try]]
          hc <- hc_try
          break
        }
      }
    }

    # Case 2: Hessian stored directly at a fixed index (like [[3]])
    if (is.null(nhat) && length(temp) >= 3 && is.matrix(temp[[3]])) {
      nhat <- temp[[3]]
      hc <- "direct[[3]]"
    }
    
    # --- Compute SE and correlations if Hessian is valid ---
    if (is.matrix(nhat) && all(dim(nhat) == c(np, np)) && !any(is.na(nhat))) {
      message("✅ Found Hessian field '", hc, "' for method ", method[i])
      cov.try <- try(solve(nhat), silent = TRUE)
      if (!inherits(cov.try, "try-error")) {
        
        
        v <- deltamethod(
          g = lapply(paste0("~exp(x", seq_len(np), ")"), as.formula),
          mean = theta_hat,
          cov = cov.try,
          ses = FALSE
        )
        results2[[i]]$bt.stdev <- sqrt(diag(v))
        results2[[i]]$Cor <- cor(v)
      } else {
  # Try pseudoinverse fallback
  message("⚠️ Using pseudoinverse for Hessian (ill-conditioned matrix)")
  if (!requireNamespace("MASS", quietly = TRUE)) stop("Package MASS required for pseudoinverse")
  cov.try <- MASS::ginv(nhat)
  v <- deltamethod(
    g = lapply(paste0("~exp(x", seq_len(np), ")"), as.formula),
    mean = theta_hat,
    cov = cov.try,
    ses = FALSE
  )
  # } else {
        # warning("⚠️ Hessian inversion failed for method ", method[i])
      }
    } else {
      message("⚠️ No valid Hessian found for method ", method[i])
    }
    
    # --- Label everything ---
    nms <- colnames(opt_result)[par.cols]
    names(results2[[i]]$bt.par) <- nms
    names(results2[[i]]$num.grads) <- nms
    names(results2[[i]]$bt.stdev) <- nms
    rownames(results2[[i]]$Cor) <- nms
    colnames(results2[[i]]$Cor) <- nms
  }
  
  return(results2)
}

getFfromCatch <- function(C, N, M, dt = 1, upper = 10) {
  # Ensure vectors are the same length
  C <- as.numeric(C)
  N <- as.numeric(N)
  M <- as.numeric(M)
  if (length(M) == 1) M <- rep(M, length(C))
  
  Fout <- numeric(length(C))
  
  for (i in seq_along(C)) {
    # Handle invalid or zero cases
    if (is.na(C[i]) || is.na(N[i]) || N[i] <= 0 || C[i] <= 0) {
      Fout[i] <- NA
      next
    }
    
    # Define function whose root we want
    f <- function(F) N[i] * (F / (F + M[i])) * (1 - exp(-(F + M[i]) * dt)) - C[i]
    
    # Catch cannot exceed total removals (sanity check)
    maxC <- N[i] * (1 - exp(-M[i] * dt))
    if (C[i] > maxC) warning(sprintf("Catch[%d] > possible removals; check data.", i))
    
    # Solve for F
    root <- try(uniroot(f, lower = 1e-8, upper = upper)$root, silent = TRUE)
    Fout[i] <- if (inherits(root, "try-error")) NA else root
  }
  
  return(Fout)
}


```

```{r}
#| echo: false
#| results: hide


Rt = c(5700,40000,3500,
       21000,2700,9700,
       55000,3400,16500,
       10700,14500,2500,
       22700,12500,34400)

# Rt = rep(10000,15)

par = list(
  logRt_scaled = log(Rt),
  logalpha      = log(1.14),
  logbeta       = log(0.6),
  logK          = log(.000034),
  logN0_scaled  = log(25000),
  logM          = log(0.1)
  # logsdCt       = log(0.25 * sd(df_effort$catch[df_effort$catch>0]))  # consistent with CatDyn
)


indice_manual =
  list(
    10,11,12,
    12,12,10,11,12,
    11,10,12,8,10,
    12,11)

for(i in 0:(length(indice_manual)-1)){
  indice_manual[[i+1]] = 12*i + indice_manual[[i+1]]
}

exp_cat = 
catdynexp(cat_df, 15, c(par$logM, par$logN0_scaled, par$logRt_scaled, par$logK, par$logalpha, par$logbeta), 
          c(head(cat_df$Data[[1]]$time.step,1),
               unlist(indice_manual), #estimativa do timing da perturbacao
              tail(cat_df$Data[[1]]$time.step,1)),
          distr = 'aplnormal')

exp_cat$Model$Results$Predicted.Catch.thou


```


```{r}
#| echo: false
ggplot() + 
  geom_line(aes(x = 1:180,
                y = exp_cat$Model$Results$Predicted.Catch.thou), col = 'red') + 
    geom_line(aes(x = 1:180,
                y = exp_cat$Model$Results$Observed.Catch.thou)) + theme_bw()
```



# CatDyn

```{r}
#| echo: false

distribuicoes = c("gamma", "lognormal","normal","negbin","aplnormal", "apnormal")
optimizadores = c('CG', 'spg', 'BFGS', 'Nelder-Mead')

fit_null =
  trialer(cat_df,
          p = 15,
          M = exp(par$logM),
          N0.ini = exp(par$logN0_scaled),
          P = indice_manual,
          P.ini  = as.list(exp(par$logRt_scaled)),
          k.ini = exp(par$logK),
          alpha.ini = exp(par$logalpha),
          beta.ini  = exp(par$logbeta),
          distr = distribuicoes[6],
          method = optimizadores[2],
          itnmax = 10000,
          disp = list(100))


annual_biomass =
  CatDynBSD(fit_null$fit,
            method = names(fit_null$fit$Model),
            multi = T,
            mbw.sd = predicos$se.fit) %>% 
  mutate(TimeStep = 180,
         x =seq(2006,2020+11/12,1/12)) 

catch_cat = unlist(CatDynPred(x=fit_null$fit,method="spg")$Model$Results['Predicted.Catch.thou'])
cat_pars_1 = fit_null$fit$Model$spg$bt.par


results = fit_null$pred$Model$Results %>% 
  as.data.frame() %>% 
  mutate(x = 1:180)

natural_mortality = fit_null$fit$Model$spg$bt.par$M
natural_mortality_sd = fit_null$fit$Model$spg$bt.stdev[['M']]

f_m = results$`Observed.F.1/month`/(results$`Observed.F.1/month` + natural_mortality)

f_m_p = results$`Predicted.F.1/month`/(results$`Predicted.F.1/month` + natural_mortality)
```

```{r}
#| echo: false

# CatDyn diagnostics

CatDynSum(x = list(fit_null$fit), season = 2022, method = 'spg')
CatDynCor(x = list(fit_null$fit), method = 'spg',
          ttl = "sexual healing",
          arr = c(1,1))
```

\[
C = N \cdot \frac{F}{F + M} \cdot \left(1 - e^{-(F + M)\,\Delta t}\right)
\]

```{r}
#| echo: false

# CatDyn biomass plot

ggplot() + 
  geom_line(aes(x = annual_biomass$x,
                y = annual_biomass$B.ton,
                group = 1),
            size = 1) +
  geom_ribbon(aes(x = annual_biomass$x,
                  y = annual_biomass$B.ton,
                  ymin= annual_biomass$B.ton- 2*annual_biomass$B.ton.SE*0,
                  ymax= annual_biomass$B.ton+ 2*annual_biomass$B.ton.SE*2),
              alpha=0.2) +
 theme_bw() + labs(x = 'year', y = 'Biomass (tons)')
```

```{r}
#| echo: false

# CatDyn mortality plot

results %>% 
  ggplot() + 
  geom_line(aes(x = Period.month,
                y = `Observed.F.1/month`),
            col = 'tomato',
            size = 1) +
  geom_line(aes(x = Period.month,
                y = `Predicted.F.1/month`),
            col = 'darkred',
            size = 1,
            linetype = 2) + 
  geom_hline(yintercept = natural_mortality,
             col = 'darkgreen',
             size = 1,
             linetype = 1) +
  geom_hline(yintercept = natural_mortality + 2*natural_mortality_sd,
             col = 'darkgreen',
             size = 1,
             linetype = 2) +
  geom_hline(yintercept = natural_mortality - 2*natural_mortality_sd,
             col = 'darkgreen',
             size = 1,
             linetype = 2) +
  theme_bw()
```


```{r}
#| echo: false

# CatDyn exploitation plot
  
  # coord_cartesian(ylim = c(0, 300000), xlim = c(1995,2024)) +
  # theme_bw()

results %>% 
  ggplot() + 
  geom_line(aes(x = Period.month,
                y = f_m),
            col = 'tomato',
            size = 1) +
  
  geom_line(aes(x = Period.month,
                y = f_m_p),
            col = 'darkred',
            size = 1,
            linetype = 2) + 
  geom_hline(yintercept = 0.4) + 
  # geom_line(aes(x = Period.month,
  #               y = `Observed.F.1/month`/(`Observed.F.1/month`+ natural_mortality)),
  #           col = 'purple',
  #           size = 1) +
  # geom_hline(yintercept = 0.4,
  #            col = 'darkgreen',
  #            size = 1,
  #            linetype = 1) +
  theme_bw()
```


# RTMB


## Parameters to be estimated

-   $\alpha$ is the abundance response

-   $\beta$ is the effort response

Both allow non-linearity for $E_t$ and $N_t$;

-   $k$ is a scaling factor

-   $M$ is the natural mortality (with $m = e^{-\frac{M}{2}}$)

-   $N_0$ is the initial abundance of the stock at $t_0$

-  $R_j$ are the recruitment pulse magnitudes

## Model 3.1: GDM, as seen on CatDyn


```{r}
#| results: hide
#| warning: false
#| echo: false

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par # already defined on catdyn chunk

# initialize joint negative loglikelihood function

jnll = function(par) {
  getAll(par, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K      = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  # sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  # jnll = -sum(dnorm(Ct, mean = predcat, sd = sdCt, log = TRUE))
  
  #adjusted normal profile version
  jnll = sum(((Ct - predcat)^2)/1^2) # 1 passa para sdCt
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(nstep)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj = MakeADFun(jnll, par)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

lower <- list(
  logRt_scaled = rep(Rt_min, 9),
  logalpha = -10, logbeta = -10, logK = -10,
  logN0_scaled = -10, logM = -10, logsdCt = -10
)

upper <- list(
  logRt_scaled = rep(Rt_max, 9),
  logalpha = 10, logbeta = 10, logK = 10,
  logN0_scaled = 10, logM = 10, logsdCt = 10
)

# Run optimizer
fit_nlmimb = nlminb(obj$par, obj$fn, obj$gr)
fit_nlmimb_nogr = nlminb(obj$par, obj$fn, NULL)
# lower = unlist(lower),
# upper = unlist(upper))

spg1 = optimx(par = obj$par,
             fn = obj$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)




# Retrieve predicted catch
predicted_catch = obj$report()$predcat
sdr = sdreport(obj)
pl = as.list(sdr,"Est")
plsd = as.list(sdr,"Std")


```

```{r}
#| echo: false

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```


```{r}
#| echo: false
#| results: hide

# report from catdyn
fit_null$fit$Model$spg

cobaia_ref = 
report_manual(p = 15,
              method = 'spg',
              opt_result = fit_null$fit$optim,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par)
cobaia =
report_manual(p = 15,
              method = 'spg',
              opt_result = spg1,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par)

catdynpred <- CatDynPred(x=fit_null$fit,method="spg")
predicted_catch = obj$report()$predcat #RTMB


cat_pars_1 = fit_null$fit$Model$spg$bt.par
```


```{r}
#| output: asis
#| echo: false
#| cap-location: top

xtable(data.frame(
                  alpha = c(cat_pars_1$`alpha.MIS+OTB-S`, exp(spg1['logalpha']) %>% unlist,
                            exp(fit_nlmimb$par['logalpha']),  exp(fit_nlmimb_nogr$par['logalpha'])),
                  beta = c(cat_pars_1$`beta.MIS+OTB-S`, exp(spg1['logbeta'])%>% unlist,
                           exp(fit_nlmimb$par['logbeta']),  exp(fit_nlmimb_nogr$par['logbeta'])),
                  k = c(cat_pars_1$`k.MIS+OTB-S`,  exp(spg1['logK'])%>% unlist,
                        exp(fit_nlmimb$par['logK']),  exp(fit_nlmimb_nogr$par['logK'])),
                  M = c(cat_pars_1$`M`,  exp(spg1['logM'])%>% unlist,
                        exp(fit_nlmimb$par['logM']),  exp(fit_nlmimb_nogr$par['logM'])),
                  N0 = c(cat_pars_1$N0,  exp(spg1['logN0_scaled'])%>% unlist,
                         exp(fit_nlmimb$par['logN0_scaled']),  exp(fit_nlmimb_nogr$par['logN0_scaled'])),
                  # SD_Ct = c("NA", exp(spg1["logsdCt"])%>% unlist,
                            # exp(fit_nlmimb$par['logsdCt']),  exp(fit_nlmimb_nogr$par['logsdCt'])),
                  R1 = c(cat_pars_1$`P1.MIS+OTB-S`,spg1[1]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[1]),  exp(fit_nlmimb_nogr$par[1])),
                  R2 = c(cat_pars_1$`P2.MIS+OTB-S`,spg1[2]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[2]),  exp(fit_nlmimb_nogr$par[2])),
                  R3 = c(cat_pars_1$`P3.MIS+OTB-S`,spg1[3]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[3]),  exp(fit_nlmimb_nogr$par[3])),
                  R4 = c(cat_pars_1$`P4.MIS+OTB-S`,spg1[4]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[4]),  exp(fit_nlmimb_nogr$par[4])),
                  R5 = c(cat_pars_1$`P5.MIS+OTB-S`,spg1[5]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[5]),  exp(fit_nlmimb_nogr$par[5])),
                  R6 = c(cat_pars_1$`P6.MIS+OTB-S`,spg1[6]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[6]),  exp(fit_nlmimb_nogr$par[6])),
                  R7 = c(cat_pars_1$`P7.MIS+OTB-S`,spg1[7]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[7]),  exp(fit_nlmimb_nogr$par[7])),
                  R8 = c(cat_pars_1$`P8.MIS+OTB-S`,spg1[8]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[8]),  exp(fit_nlmimb_nogr$par[8])),
                  R9 = c(cat_pars_1$`P9.MIS+OTB-S`,spg1[9]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[9]),  exp(fit_nlmimb_nogr$par[9])),
                  R10 = c(cat_pars_1$`P10.MIS+OTB-S`,spg1[10]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[10]),  exp(fit_nlmimb_nogr$par[10])),
                  R11 = c(cat_pars_1$`P11.MIS+OTB-S`,spg1[11]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[11]),  exp(fit_nlmimb_nogr$par[11])),
                  R12 = c(cat_pars_1$`P12.MIS+OTB-S`,spg1[12]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[12]),  exp(fit_nlmimb_nogr$par[12])),
                  R13 = c(cat_pars_1$`P13.MIS+OTB-S`,spg1[13]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[13]),  exp(fit_nlmimb_nogr$par[13])),
                  R14 = c(cat_pars_1$`P14.MIS+OTB-S`,spg1[14]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[14]),  exp(fit_nlmimb_nogr$par[14])),
                  R15 = c(cat_pars_1$`P15.MIS+OTB-S`,spg1[15]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[15]),  exp(fit_nlmimb_nogr$par[15])),
                  row.names = c('CatDyn', 'RTMB_spg','RTMB_nlmimb', 'RTMB_nlmimb_nogradient')) %>% t, digits = 8) %>%
  print(comment = F,
        sanitize.text.function = function(x)
          {gsub("_", "\\\\_", x)})


```

```{r}
#| echo: false
ggplot() + 
  geom_line(aes(x = 1:180,
                y = unlist(catdynpred$Model$Results['Predicted.Catch.thou']))) +   
  geom_line(aes(x = 1:180,
                y = predicted_catch), col = 'red') + 
  theme_bw() + 
  labs(y = 'catch', title = 'Catdyn (black), RTMB (red)')
```



## RTMB With $K(t)$

```{r}
#| results: hide
#| warning: false
#| echo: false
#| eval: true

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)
nS = ceiling(nT/12) # of seasons

season = matrix(0, nrow = nT, ncol = nS)
for (j in 1:nS) {
  season[(j-1) * 12  + (1:12), j] <- 1 # .
}  

I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I
dat$season = season

# Initial parameter values
par_kt = par # already defined on catdyn chunk
par_kt$logkt = rep(par$logK, ceiling(nT/12))

# initialize joint negative loglikelihood function

jnll_kt = function(par_kt) {
  getAll(par_kt, dat)


  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  Kt     = exp(logkt)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  # sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
  
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) 
      mccum[i] * exp(-M/2)
    
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- season[i, ceiling(i/12)] * Kt * (effeff1 * effn1) * exp(-M/2)
    # season_i <- ceiling(i / 12)
    # season_i <- min(season_i, length(Kt))  # safety check

    # effeff1 <- Et[i]^alpha
    # effn1   <- nstep[i]^beta
    # 
    # predcat[i] <- Kt[season_i] * effeff1 * effn1 * exp(-M/2)
    }
  
  # Negative log-likelihood
  # jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
    jnll = sum(((Ct - predcat)^2)/1^2)
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(Kt)
    REPORT(nstep)
  jnll

}

# quick test: do we get a number? This number should be a likelihood.
jnll_kt(par_kt)

obj_kt = MakeADFun(jnll_kt, par_kt)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

lower <- list(
  logRt_scaled = rep(Rt_min, 9),
  logalpha = -10, logbeta = -10, logK = -10,
  logN0_scaled = -10, logM = -10, logsdCt = -10
)

upper <- list(
  logRt_scaled = rep(Rt_max, 9),
  logalpha = 10, logbeta = 10, logK = 10,
  logN0_scaled = 10, logM = 10, logsdCt = 10
)

# Run optimizer
fit_nlmimb_kt = nlminb(obj_kt$par, obj_kt$fn, obj_kt$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_kt = optimx(par = obj_kt$par,
             fn = obj_kt$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)



obj_kt$report()$Kt
obj_kt$report()$nstep
obj_kt$report()$predcat

# Retrieve predicted catch
predicted_catch_kt = obj_kt$report()$predcat
sdr_kt = sdreport(obj_kt)
pl_kt = as.list(sdr_kt,"Est")
plsd_kt = as.list(sdr_kt,"Std")


```


```{r}
#| echo: false
#| eval: true

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch_kt), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```

## RTMB With $alpha(t)$

```{r}
#| results: hide
#| warning: false
#| echo: false
#| eval: true

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par_at = par # already defined on catdyn chunk
par_at$logalpha = rep(par$logalpha, ceiling(nT/12))

# initialize joint negative loglikelihood function

jnll_at = function(par_at) {
  getAll(par_at, dat)
  # logalpha <- advector(logalpha)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K     = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  # sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)


  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * beta#init vector
mccum = vector("numeric", nT) * beta
effeff1 = vector("numeric", nT) * beta
effn1 = vector("numeric", nT) * beta
predcat = vector("numeric", nT) * beta

seasons = ceiling(1:nT / 12)
alpha_seasonal = alpha[seasons]

  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    season = ceiling(i/12)
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    
    effeff1 <- Et^(alpha_seasonal)
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  # jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
    jnll = sum(((Ct - predcat)^2)/1^2) 
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(alpha)
    REPORT(nstep)
    

  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll_at(par_at)

obj_at = MakeADFun(jnll_at, par_at)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

# lower <- list(
#   logRt_scaled = rep(Rt_min, 9),
#   logalpha = -10, logbeta = -10, logK = -10,
#   logN0_scaled = -10, logM = -10, logsdCt = -10
# )
# 
# upper <- list(
#   logRt_scaled = rep(Rt_max, 9),
#   logalpha = 10, logbeta = 10, logK = 10,
#   logN0_scaled = 10, logM = 10, logsdCt = 10
# )

# Run optimizer
fit_nlmimb_at = nlminb(obj_at$par, obj_at$fn, obj_at$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_at = optimx(par = obj_at$par,
             fn = obj_at$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)



obj_at$report()$alpha
obj_at$report()$nstep
obj_at$report()$predcat

# Retrieve predicted catch
predicted_catch_at = obj_at$report()$predcat
sdr_at = sdreport(obj_at)
pl_at = as.list(sdr_at,"Est")
plsd_at = as.list(sdr_at,"Std")


```

```{r}
#| echo: false
#| eval: true

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch_at), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```



## RTMB With $beta(t)$

```{r}
#| results: hide
#| warning: false
#| echo: false
#| eval: true

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par_bt = par # already defined on catdyn chunk
par_bt$logbeta = rep(par$logbeta, ceiling(nT/12))

# initialize joint negative loglikelihood function

jnll_bt = function(par_bt) {
  getAll(par_bt, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K     = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  # sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha

seasons = ceiling(1:nT / 12)
beta_seasonal = beta[seasons]

  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    season = ceiling(i/12)
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta_seasonal)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  # jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
    jnll = sum(((Ct - predcat)^2)/1^2)
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(beta)
    REPORT(nstep)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll_bt(par_bt)

obj_bt = MakeADFun(jnll_bt, par_bt)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

# lower <- list(
#   logRt_scaled = rep(Rt_min, 9),
#   logalpha = -10, logbeta = -10, logK = -10,
#   logN0_scaled = -10, logM = -10, logsdCt = -10
# )
# 
# upper <- list(
#   logRt_scaled = rep(Rt_max, 9),
#   logalpha = 10, logbeta = 10, logK = 10,
#   logN0_scaled = 10, logM = 10, logsdCt = 10
# )

# Run optimizer
fit_nlmimb_bt = nlminb(obj_bt$par, obj_bt$fn, obj_bt$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_bt = optimx(par = obj_bt$par,
             fn = obj_bt$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)



obj_bt$report()$beta
obj_bt$report()$nstep
obj_bt$report()$predcat

# Retrieve predicted catch
predicted_catch_bt = obj_bt$report()$predcat
sdr_bt = sdreport(obj_bt)
pl_bt = as.list(sdr_bt,"Est")
plsd_bt = as.list(sdr_bt,"Std")


```

```{r}
#| echo: false
#| eval: true

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch_at), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```



## RTMB With Rainfall

```{r}
#| results: hide
#| warning: false
#| echo: false
#| eval: true

rain = 
chuva %>% group_by(year) %>% 
  summarise(precip = sum(precip))

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)
dat$Rf = rain$precip[12:27]# recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par_rf = par
par_rf$loggamma = log(1)

# initialize joint negative loglikelihood function

jnll_rf = function(par_rf) {
  getAll(par_rf, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  Rf = OBS(Rf)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K     = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  # sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)
  gamma = exp(loggamma)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
ambient = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


seasons = ceiling(1:nT / 12)

  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    season = ceiling(i/12)
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    ambient = Rf[seasons]^gamma
    predcat <- K * (effeff1 * effn1 * ambient) * exp(-M/2)
  }
  
  # Negative log-likelihood
  # jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
    jnll = sum(((Ct - predcat)^2)/1^2)
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(gamma)
    REPORT(nstep)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll_rf(par_rf)

obj_rf = MakeADFun(jnll_rf, par_rf)

# Run optimizer
fit_nlmimb_rf = nlminb(obj_rf$par, obj_rf$fn, obj_rf$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_rf = optimx(par = obj_rf$par,
             fn = obj_rf$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)



obj_rf$report()$gamma
obj_rf$report()$nstep
obj_rf$report()$predcat

# Retrieve predicted catch
predicted_catch_rf = obj_rf$report()$predcat
sdr_rf = sdreport(obj_rf)
pl_rf = as.list(sdr_rf,"Est")
plsd_rf = as.list(sdr_rf,"Std")


```

```{r}
#| echo: false
#| eval: true

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch_rf), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```

## Simpler

```{r}
#| results: hide
#| warning: false
#| echo: false
#| eval: true


nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)
dat$Rf = rain$precip[12:27]# recruitment pulse months
# dat$Rf = rain$precip[12:27]# recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par_nf = par
# par_rf$loggamma = log(1)
par_nf = par[-2]


# initialize joint negative loglikelihood function

jnll_nf = function(par_nf) {
  getAll(par_nf, dat[-c(2,4)])

  # Extract parameters
  Ct     = OBS(Ct)
  # Et     = OBS(Et)
  # Rf = OBS(Rf)
  I  = OBS(I)
  # alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K     = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  # sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)
  # gamma = exp(loggamma)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * beta#init vector
mccum = vector("numeric", nT) * beta
# effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * beta
# ambient = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * beta


# seasons = ceiling(1:nT / 12)

  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    season = ceiling(i/12)
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    # effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    # ambient = Rf[seasons]^gamma
    predcat <- K * (effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  # jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
    jnll = sum(((Ct - predcat)^2)/1^2)
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(beta)
    REPORT(nstep)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll_nf(par_nf)

obj_nf = MakeADFun(jnll_nf, par_nf)

# Run optimizer
fit_nlmimb_nf = nlminb(obj_nf$par, obj_nf$fn, obj_nf$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_nf = optimx(par = obj_nf$par,
             fn = obj_nf$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)




obj_nf$report()$nstep
obj_nf$report()$predcat

# Retrieve predicted catch
predicted_catch_nf = obj_nf$report()$predcat
sdr_nf = sdreport(obj_nf)
pl_nf = as.list(sdr_nf,"Est")
plsd_nf = as.list(sdr_nf,"Std")


```


```{r}
#| echo: false
#| eval: true

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch_nf), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```



```{r}
#| echo: false
#| eval: false

# results from RTMB catch prediction 

todos = data.frame(x = 1:nT,
                   base = predicted_catch,
                   kt = predicted_catch_kt,
                   at = predicted_catch_at,
                   bt = predicted_catch_bt,
                   rf = predicted_catch_rf,
                   simp = predicted_catch_nf) %>% pivot_longer(cols = -c(x)) %>% 
  mutate(data = rep(dat$Ct, each = 6))

todos %>% 
ggplot() + 
  geom_line(aes(x = x,
                y = value,
            group = name,
            color = name), size = 1) +
     geom_line(aes(x = x,
                y = data,
                group = 1), linetype = 'dashed', size = 0.5) + 
  facet_wrap(.~name, ncol = 2) + 
  theme_bw() + 
  labs(x = '', y = 'tons', color = '') + 
  theme(legend.position = 'none') + 
  scale_color_manual(values = colorRampPalette(wes_palette('Zissou1'))(6))
```



```{r}

data_frame(year = 2006:2020,
           Kt = obj_kt$report()$Kt,
           at = obj_at$report()$alpha,
           bt = obj_bt$report()$beta) %>% 
  pivot_longer(cols = -c(year)) %>% 
  ggplot() + 
  geom_line(aes(x = year,
                y = value,
                group = name,
                color = name),
            size = 1) + 
  facet_wrap(.~name, ncol = 1, scale = 'free_y') + 
  scale_color_manual(values = colorRampPalette(wes_palette('Zissou1'))(3)) +
  theme_bw() + 
  labs(x = '', y = '', color = '') +
  theme(legend.position = 'none') 


```

```{r}


```


```{r}
library(numDeriv)
# CatDyn

fit_null$fit$Model$spg$bt.par
fit_null$fit$Model$spg$bt.stdev
fit_null$fit$Model$spg$Cor -> queca



# base

rep_1 =
report_manual_beta(p = 15,
              method = 'spg',
              opt_result = spg1,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par)

rep_1$spg$bt.par
rep_1$spg$bt.stdev
rep_1$spg$Cor


# kt
rep_kt =
report_manual_beta(p = 15,
              method = 'spg',
              opt_result = spg1_kt,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par_kt)

exp(spg1_kt)
rep_kt$spg$bt.par
rep_kt$spg$bt.stdev
rep_kt$spg$Cor

# at
rep_at =
report_manual_beta(p = 15,
              method = 'spg',
              opt_result = spg1_at,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par_at)

exp(spg1_at)
rep_at$spg$bt.par
rep_at$spg$bt.stdev
rep_at$spg$Cor %>% hist


# bt
rep_bt =
report_manual_beta(p = 15,
              method = 'spg',
              opt_result = spg1_bt,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par_bt)

exp(spg1_bt)
rep_bt$spg$bt.par
rep_bt$spg$bt.stdev
rep_bt$spg$Cor


# rf
rep_rf =
report_manual_beta(p = 15,
              method = 'spg',
              opt_result = spg1_rf,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par_rf)

exp(spg1_rf)
rep_rf$spg$bt.par
rep_rf$spg$bt.stdev
rep_rf$spg$Cor

# nf
rep_nf =
report_manual_beta(p = 15,
              method = 'spg',
              opt_result = spg1_nf,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'apnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par_nf)

exp(spg1_nf)
rep_nf$spg$bt.par
rep_nf$spg$bt.stdev
rep_nf$spg$Cor

```


```{r}
# M
data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>%
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$bt.par$M,
                      rep_1$spg$bt.par['logM'],
                      rep_kt$spg$bt.par['logM'],
                      rep_at$spg$bt.par['logM'],
                      rep_bt$spg$bt.par['logM'],
                      rep_rf$spg$bt.par['logM'],
                      rep_nf$spg$bt.par['logM']),
           dev = c(fit_null$fit$Model$spg$bt.stdev['M'],
                      rep_1$spg$bt.stdev['logM'],
                      rep_kt$spg$bt.stdev['logM'],
                      rep_at$spg$bt.stdev['logM'],
                      rep_bt$spg$bt.stdev['logM'],
                      rep_rf$spg$bt.stdev['logM'],
                      rep_nf$spg$bt.stdev['logM'])) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev)) %>% 
  ggplot() + 
  geom_bar_pattern(aes(x = models,
               y = estimate + 2 * dev),
               stat = 'sum') +
   geom_bar(aes(x = models,
               y = estimate),
               stat = 'sum',
            fill = colorRampPalette(wes_palette('Zissou1'))(5)[1]) +
  theme_bw() + 
  labs(title = 'M', y = '') + 
  theme(legend.position = 'none') 


data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>%
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$bt.par$N0,
                      rep_1$spg$bt.par['logN0_scaled'],
                      rep_kt$spg$bt.par['logN0_scaled'],
                      rep_at$spg$bt.par['logN0_scaled'],
                      rep_bt$spg$bt.par['logN0_scaled'],
                      rep_rf$spg$bt.par['logN0_scaled'],
                      rep_nf$spg$bt.par['logN0_scaled']),
           dev = c(fit_null$fit$Model$spg$bt.stdev['N0'],
                      rep_1$spg$bt.stdev['logN0_scaled'],
                      rep_kt$spg$bt.stdev['logN0_scaled'],
                      rep_at$spg$bt.stdev['logN0_scaled'],
                      rep_bt$spg$bt.stdev['logN0_scaled'],
                      rep_rf$spg$bt.stdev['logN0_scaled'],
                      rep_nf$spg$bt.stdev['logN0_scaled'])) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev)) %>% 
  ggplot() + 
  geom_bar_pattern(aes(x = models,
               y = estimate + 2 * dev),
               stat = 'sum') +
   geom_bar(aes(x = models,
               y = estimate),
               stat = 'sum',
            fill = colorRampPalette(wes_palette('Zissou1'))(5)[2]) +
  theme_bw() + 
  labs(title = 'N0', y = '') + 
  theme(legend.position = 'none') 

data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>%
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$bt.par$`k.MIS+OTB-S`,
                      rep_1$spg$bt.par['logK'],
                      rep_kt$spg$bt.par['logK'],
                      rep_at$spg$bt.par['logK'],
                      rep_bt$spg$bt.par['logK'],
                      rep_rf$spg$bt.par['logK'],
                      rep_nf$spg$bt.par['logK']),
           dev = c(fit_null$fit$Model$spg$bt.stdev['k.MIS+OTB-S'],
                      rep_1$spg$bt.stdev['logK'],
                      rep_kt$spg$bt.stdev['logK'],
                      rep_at$spg$bt.stdev['logK'],
                      rep_bt$spg$bt.stdev['logK'],
                      rep_rf$spg$bt.stdev['logK'],
                      rep_nf$spg$bt.stdev['logK'])) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev)) %>% 
  ggplot() + 
  geom_bar_pattern(aes(x = models,
               y = estimate + 2 * dev),
               stat = 'sum') +
   geom_bar(aes(x = models,
               y = estimate),
               stat = 'sum',
            fill = colorRampPalette(wes_palette('Zissou1'))(5)[3]) +
  theme_bw() + 
  labs(title = 'K', y = '') + 
  theme(legend.position = 'none')


data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>%
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$bt.par$`alpha.MIS+OTB-S`,
                      rep_1$spg$bt.par['logalpha'],
                      rep_kt$spg$bt.par['logalpha'],
                      rep_at$spg$bt.par['logalpha'],
                      rep_bt$spg$bt.par['logalpha'],
                      rep_rf$spg$bt.par['logalpha'],
                      rep_nf$spg$bt.par['logalpha']),
           dev = c(fit_null$fit$Model$spg$bt.stdev['alpha.MIS+OTB-S'],
                      rep_1$spg$bt.stdev['logalpha'],
                      rep_kt$spg$bt.stdev['logalpha'],
                      rep_at$spg$bt.stdev['logalpha'],
                      rep_bt$spg$bt.stdev['logalpha'],
                      rep_rf$spg$bt.stdev['logalpha'],
                      rep_nf$spg$bt.stdev['logalpha'])) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev)) %>% 
  ggplot() + 
  geom_bar_pattern(aes(x = models,
               y = estimate + 2 * dev),
               stat = 'sum') +
   geom_bar(aes(x = models,
               y = estimate),
               stat = 'sum',
            fill = colorRampPalette(wes_palette('Zissou1'))(5)[4]) +
  theme_bw() + 
  labs(title = 'alpha', y = '') + 
  theme(legend.position = 'none') 

data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>%
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$bt.par$`beta.MIS+OTB-S`,
                      rep_1$spg$bt.par['logbeta'],
                      rep_kt$spg$bt.par['logbeta'],
                      rep_at$spg$bt.par['logbeta'],
                      rep_bt$spg$bt.par['logbeta'],
                      rep_rf$spg$bt.par['logbeta'],
                      rep_nf$spg$bt.par['logbeta']),
           dev = c(fit_null$fit$Model$spg$bt.stdev['beta.MIS+OTB-S'],
                      rep_1$spg$bt.stdev['logbeta'],
                      rep_kt$spg$bt.stdev['logbeta'],
                      rep_at$spg$bt.stdev['logbeta'],
                      rep_bt$spg$bt.stdev['logbeta'],
                      rep_rf$spg$bt.stdev['logbeta'],
                      rep_nf$spg$bt.stdev['logbeta'])) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev)) %>% 
  ggplot() + 
  geom_bar_pattern(aes(x = models,
               y = estimate + 2 * dev),
               stat = 'sum') +
   geom_bar(aes(x = models,
               y = estimate),
               stat = 'sum',
            fill = colorRampPalette(wes_palette('Zissou1'))(5)[5]) +
  theme_bw() + 
  labs(title = 'beta', y = '') + 
  theme(legend.position = 'none') 

```


```{r}
data.frame(Parameters = c('M', 'N0', 'k', 'alpha', 'beta') %>%
             factor(levels = c('M', 'N0', 'k', 'alpha', 'beta'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$bt.par$M,
                        fit_null$fit$Model$spg$bt.par$N0,
                        fit_null$fit$Model$spg$bt.par$`k.MIS+OTB-S`,
                        fit_null$fit$Model$spg$bt.par$`alpha.MIS+OTB-S`,
                        fit_null$fit$Model$spg$bt.par$`beta.MIS+OTB-S`),
           dev = c(fit_null$fit$Model$spg$bt.stdev['M'],
                   fit_null$fit$Model$spg$bt.stdev['N0'],
                   fit_null$fit$Model$spg$bt.stdev['k.MIS+OTB-S'],
                   fit_null$fit$Model$spg$bt.stdev['alpha.MIS+OTB-S'],
                   fit_null$fit$Model$spg$bt.stdev['beta.MIS+OTB-S']
                      )) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev)) %>% 
  ggplot() + 
  geom_bar_pattern(aes(x = Parameters,
               y = log(estimate + 2 * dev)),
               stat = 'sum') +
   geom_bar(aes(x = Parameters,
               y = log(estimate)),
               stat = 'sum',
            fill = colorRampPalette(wes_palette('Zissou1'))(5)[1]) +
  theme_bw() + 
  labs(title = 'Base fit in CatDyb', y = '') + 
  theme(legend.position = 'none') 

```


```{r}
data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>%
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T) %>%  rep(., each = 15),
           estimate = c(fit_null$fit$Model$spg$bt.par[grepl('P', names(fit_null$fit$Model$spg$bt.par))],
                      rep_1$spg$bt.par[grepl('logRt', names(rep_1$spg$bt.par))] %>% unlist() ,
                      rep_kt$spg$bt.par[grepl('logRt', names(rep_kt$spg$bt.par))] %>% unlist(),
                      rep_at$spg$bt.par[grepl('logRt', names(rep_at$spg$bt.par))] %>% unlist(),
                      rep_bt$spg$bt.par[grepl('logRt', names(rep_bt$spg$bt.par))] %>% unlist(),
                     rep_rf$spg$bt.par[grepl('logRt', names(rep_rf$spg$bt.par))] %>% unlist(),
                     rep_nf$spg$bt.par[grepl('logRt', names(rep_nf$spg$bt.par))]%>% unlist()) %>% unlist(),
           dev = c(fit_null$fit$Model$spg$bt.stdev[grepl('P', names(fit_null$fit$Model$spg$bt.stdev))],
                      rep_1$spg$bt.stdev[grepl('logRt', names(rep_1$spg$bt.stdev)) %>% unlist()],
                      rep_kt$spg$bt.stdev[grepl('logRt', names(rep_kt$spg$bt.stdev)) %>% unlist()],
                      rep_at$spg$bt.stdev[grepl('logRt', names(rep_at$spg$bt.stdev)) %>% unlist()],
                      rep_bt$spg$bt.stdev[grepl('logRt', names(rep_bt$spg$bt.stdev)) %>% unlist()],
                      rep_rf$spg$bt.stdev[grepl('logRt', names(rep_rf$spg$bt.stdev)) %>% unlist()],
                      rep_nf$spg$bt.stdev[grepl('logRt', names(rep_nf$spg$bt.stdev))%>% unlist()]) %>% unlist()) %>% 
  mutate(dev = ifelse(is.na(dev), 0, dev),
         year = rep(2006:2020, times = 7)) %>% 
  # filter(models == 'beta(t)') %>% 
  ggplot() + 
  geom_line(aes(x = year,
               y = estimate/1000,
            group = models,
            color = models),
            size = 1) + 
    geom_ribbon(aes(x = year,
                    ymin =  (estimate - 2* dev)/1000,
               ymax = (estimate + 2* dev)/1000,
            group = models,
            fill = models), alpha = 0.4, outline.type = 'both') + 
  scale_color_manual(values = colorRampPalette(wes_palette('Zissou1'))(7)) +
  scale_fill_manual(values = colorRampPalette(wes_palette('Zissou1'))(7)) + 
  facet_wrap(.~models, ncol = 3) +
  theme_bw() + 
  labs(title = 'Recruitment (thou. ind.)', x = '', y = '') + 
  theme(legend.position = 'none') 

```


```{r}
obj_bt$report()$nstep

data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>% 
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T) %>%  rep(., each = 180),
           estimate = c(annual_biomass$N.thou,
                    obj_bt$report()$nstep ,
                    obj_bt$report()$nstep %>% unlist(),
                    obj_bt$report()$nstep %>% unlist(),
                    obj_bt$report()$nstep %>% unlist(),
                    obj_bt$report()$nstep %>% unlist(),
                    obj_bt$report()$nstep %>% unlist()) %>%
             unlist()) %>% 
    mutate(month = rep(1:180, times = 7)) %>% 
    ggplot() + 
  geom_line(aes(x = month,
               y = estimate/1000,
            group = models,
            color = models),
            size = 1) +
   scale_color_manual(values = colorRampPalette(wes_palette('Zissou1'))(7)) +
  facet_wrap(.~models, ncol = 3, dir = "lt") +
  theme_bw() + 
  labs(title = 'Biomass (mill. ind)', x = '', y = '') + 
  theme(legend.position = 'none') 


```

```{r}
puta = 
data.frame(
  models = c(rep('Catdyn', 400), rep('base',400), rep('k(t)',1225), rep('alpha(t)',1156), 
             rep('beta(t)',1156), rep('gamma',441), rep('Ct',361)) %>% c() %>% 
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T),
           estimate = c(fit_null$fit$Model$spg$Cor %>% c(),
                      rep_1$spg$Cor %>% c(),
                      rep_kt$spg$Cor %>% c(),
                      rep_at$spg$Cor %>% c(),
                      rep_bt$spg$Cor %>% c(),
                     rep_rf$spg$Cor %>% c(),
                     rep_nf$spg$Cor %>% c())) %>% 
  mutate(estimate = pmin(pmax(estimate, -1), 1))


hist (puta$estimate)

puta %>% 
  # filter(models == 'beta(t)') %>% 
  ggplot() + 
    geom_histogram(aes(x = estimate), bins = 10, fill = 'gray',col = 'black', boundary = 1.00) + 
  facet_wrap(.~models, ncol = 4, scales = 'free_y') +
  theme_bw() + 
  labs(title = 'Coefficients Correlation', x = '') + 
  theme(legend.position = 'none')
```


```{r}
results = fit_null$pred$Model$Results %>% 
  as.data.frame() %>% 
  mutate(x = 1:180)

natural_mortality = fit_null$fit$Model$spg$bt.par$M
natural_mortality_sd = fit_null$fit$Model$spg$bt.stdev[['M']]

f_m = results$`Observed.F.1/month`/(results$`Observed.F.1/month` + natural_mortality)

f_m_p = results$`Predicted.F.1/month`/(results$`Predicted.F.1/month` + natural_mortality)

obj$report()$predcat

data.frame(models = c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct') %>% 
             factor(levels =  c('Catdyn', 'base', 'k(t)', 'alpha(t)', 'beta(t)', 'gamma', 'Ct'),
                    ordered = T) %>%  rep(., each = 180),
           M = c(exp(spg1$logM), exp(spg1_kt$logM), exp(spg1_at$logM),
                 exp(spg1_bt$logM), exp(spg1_rf$logM),exp(spg1_nf$logM))) %>% 
  mutate(
           estimate =c(results$`Observed.F.1/month`,
                    getFfromCatch(obj$report()$predcat,
                                  obj$report()$nstep,
                                  M),
             getFfromCatch(obj_kt$report()$predcat,
                                  obj_kt$report()$nstep,
                                  M),
             getFfromCatch(obj_at$report()$predcat,
                                  obj_at$report()$nstep,
                                  M),
             getFfromCatch(obj_bt$report()$predcat,
                                  obj_bt$report()$nstep,
                                  M),
             getFfromCatch(obj_rf$report()$predcat,
                                  obj_rf$report()$nstep,
                                  M),
             getFfromCatch(obj_nf$report()$predcat,
                                  obj_nf$report()$nstep,
                                  M))) %>%  
  mutate(Exploitation = estimate/(estimate +M )) %>% 
  mutate(month = rep(1:180, times = 7)) %>% 
    ggplot() + 
  geom_line(aes(x = month,
               y = Exploitation,
            group = models,
            color = models),
            size = 1) +
   scale_color_manual(values = colorRampPalette(wes_palette('Zissou1'))(7)) +
  facet_wrap(.~models, ncol = 3) +
  theme_bw() + 
  labs(title = 'Observed exploitation rate', x = '', y= '') + 
  theme(legend.position = 'none') 

getFfromCatch(results$Observed.Catch.thou, annual_biomass$N.thou, fit_null$fit$Model$spg$bt.par$M)
  
  
```


