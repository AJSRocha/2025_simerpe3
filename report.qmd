---
title: "Polvices polvando polvivamente"
format:
   pdf:
       include-in-header:
           - text: |
                \usepackage{todonotes}
                \usepackage{graphicx}
                \usepackage{amsmath}
       documentclass: asaproc
       classoption: [11pt]
editor: source
cite-method: biblatex
bibliography: Polvices.bib
biblatexoptions: 
  - citestyle=authoryear
author:
  - name: "Alberto Rocha \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: true
  - name: "Ana Moreno \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: false
number-sections: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| eval: false
#| echo: false
tinytex::parse_install("report.log")
tinytex::tlmgr_update()


# https://cameronpatrick.com/post/2023/07/quarto-thesis-formatting/
```

```{r setup}
#| include: false

library(CatDyn)
library(RTMB)
library(optimx)
library(wesanderson)
library(tidyverse)
library(xtable)
library(tmbstan)
library(shinystan)

source('scripts/custom_catdyn_fit.R')
source('scripts/custom_catdyn_bsd.R')
source('scripts/funcoes_catdyn.R')

load("data/df_effort_m_mbw_otb.Rdata")
load('data/mbw_model.Rdata')

mod_aux = lm(df_effort$catch ~ df_effort$effort)

# Fix a couple of outliers

# df_effort =
#   vd %>%
#   group_by(year_sale, month_sale, IEMBARCA, PORTO) %>%
#   summarise(Power.Main.raw = mean(Power.Main, na.rm = T),
#             Power.main = trunc(Power.Main.raw/50) * 50,
#             catch_i = sum(QVENDA[EGRUPART == 'MIS_MIS']),
#             catch_i_otb = sum(QVENDA),
#             effort_i = n_distinct(IDATVEND[EGRUPART == 'MIS_MIS']),
#             effort_i_otb = n_distinct(IDATVEND))


df_effort = 
  df_effort %>% 
  # mutate(catch = case_when(year_sale == 2005 &
  #                            month_sale == '09' ~
  #                            effort * mod_aux$coefficients[2] +
  #                            mod_aux$coefficients[1],
  #                          T ~ catch),
  #        catch_otb = case_when(year_sale == 2005 &
  #                                month_sale == '09' ~
  #                                effort_otb * mod_aux$coefficients[2] +
  #                                mod_aux$coefficients[1],
  #                              T ~ catch_otb)) %>% 
  mutate(catch_otb = case_when(catch_otb == 0 ~ 0.1, 
                               T ~ catch_otb)
         # effort_otb = case_when(effort_otb  < 150 ~ mean(effort_otb),
         #                        T ~ effort_otb)
                                )
                                
cat_df = as.CatDynData(x=df_effort %>%
                         filter(as.numeric(
                           as.character(year_sale)) %in% c(2006:2020)),
                       step="month",
                       fleet.name="MIS+OTB-S",
                       coleff=6,
                       colcat=5,
                       colmbw=9,
                       unitseff="trips",
                       unitscat="kg",
                       unitsmbw="kg",
                       nmult="thou",
                       season.dates=c(as.Date("2006-01-01"),
                                      last_date_of_week(2020, 52)-1))

report_manual = function(p, method, dates,
                         distr, fleet.name, par.tmp,
                         opt_result){
  results2 = vector("list", length(method))
      names(results2) = method
      temp = attr(opt_result, "details")
      for (i in 1:length(method)) {
        results2[[i]]$Type <- p
        results2[[i]]$Dates <- dates
        names(results2[[i]]$Dates) <- c("ts.start",
                                        paste0('ts.', seq(1:p)),
                                        "ts.end")
        results2[[i]]$Distr <- distr
        par.names <- c("M", "N0", paste0('P', seq(1:p), ".", rep(fleet.name,p)),
                       paste(c("k.", "alpha.", "beta."), fleet.name, sep = ""))
        
        if (distr %in% c("negbin", "normal" ,
                         "lognormal",  "gamma",
                         "roblognormal", "gumbel")) {
          par.names <- c(par.names, paste("psi.", fleet.name, 
            sep = ""))
        }
        
        results2[[i]]$converg <- "FAIL"
        results2[[i]]$kkt <- NA
        results2[[i]]$AIC <- NA
        results2[[i]]$bt.par <- NA
        results2[[i]]$num.grads <- NA
        results2[[i]]$bt.stdev <- NA
        results2[[i]]$Cor <- matrix(NA, length(par.names), 
          length(par.names))
        
        if (length(temp[i, ]$ngatend) == length(par.names) & 
          !any(is.na(temp[i, ]$nhatend)) & 1/kappa(temp[i, 
          ]$nhatend) > 1e-15) {
          results2[[i]]$converg <- opt_result[i, length(par.tmp) + 
            5]
          results2[[i]]$kkt <- opt_result[i, (length(par.tmp) + 
            6):(length(par.tmp) + 7)]
          results2[[i]]$AIC <- 2 * length(par.tmp) + 2 * 
            opt_result[i, length(par.tmp) + 1]
          results2[[i]]$bt.par <- exp(opt_result[i, (1:length(par.tmp))])
          results2[[i]]$num.grads <- temp[i, ]$ngatend
          
          v <- matrix(0, length(par.names), length(par.names))
          
          if (distr %in% c("poisson",  "apnormal", "aplnormal")) {
            v <- deltamethod(
    g = lapply(paste0('~exp(x', 1:length((par.tmp)-1), ')'), as.formula),
    mean = as.numeric(opt_result[i, 1:length((par.tmp)-1)]),
    cov = try(solve(temp[i, ]$nhatend)),
    ses = FALSE
)
          }
          else {
            v <- deltamethod(
            g = lapply(paste0('~exp(x', seq_along(par.tmp), ')'), as.formula),
            mean = as.numeric(opt_result[i, 1:length(par.tmp)]),
            cov = try(solve(temp[i, ]$nhatend)),
            ses = FALSE
)
          }
          results2[[i]]$bt.stdev <- sqrt(diag(v))
          results2[[i]]$Cor <- cor(v)
          names(results2[[i]]$num.grads) <- par.names
          names(results2[[i]]$bt.par) <- par.names
          names(results2[[i]]$bt.stdev) <- par.names
          colnames(results2[[i]]$Cor) <- par.names
          rownames(results2[[i]]$Cor) <- par.names 
        } else {print('convergencia e meio merdosa')}}
        return(results2)}      
```

```{r}
#| echo: false
#| results: hide
par = list(
  logRt_scaled = log(c(5700,40000,3500,
                       21000,2700,9700,
                       55000,3400,16500,
                       10700,14500,2500,
                       22700,12500,34400)),
  logalpha      = log(1.14),
  logbeta       = log(0.6),
  logK          = log(.000034),
  logN0_scaled  = log(25000),
  logM          = log(0.1),
  logsdCt       = log(0.25 * sd(df_effort$catch[df_effort$catch>0]))  # consistent with CatDyn
)


indice_manual =
  list(
    10,11,12,
    12,12,10,11,12,
    11,10,12,8,10,
    12,11)

for(i in 0:(length(indice_manual)-1)){
  indice_manual[[i+1]] = 12*i + indice_manual[[i+1]]
}

exp_cat = 
catdynexp(cat_df, 15, c(par$logM, par$logN0_scaled, par$logRt_scaled, par$logK, par$logalpha, par$logbeta), 
          c(head(cat_df$Data[[1]]$time.step,1),
               unlist(indice_manual), #estimativa do timing da perturbacao
              tail(cat_df$Data[[1]]$time.step,1)),
          distr = 'aplnormal')

exp_cat$Model$Results$Predicted.Catch.thou


```


```{r}
#| echo: false
ggplot() + 
  geom_line(aes(x = 1:180,
                y = exp_cat$Model$Results$Predicted.Catch.thou), col = 'red') + 
    geom_line(aes(x = 1:180,
                y = exp_cat$Model$Results$Observed.Catch.thou)) + theme_bw()
```



# CatDyn

```{r}
#| echo: false

distribuicoes = c("gamma", "lognormal","normal","negbin","aplnormal", "apnormal")
optimizadores = c('CG', 'spg', 'BFGS', 'Nelder-Mead')

fit_null =
  trialer(cat_df,
          p = 15,
          M = exp(par$logM),
          N0.ini = exp(par$logN0_scaled),
          P = indice_manual,
          P.ini  = as.list(exp(par$logRt_scaled)),
          k.ini = exp(par$logK),
          alpha.ini = exp(par$logalpha),
          beta.ini  = exp(par$logbeta),
          distr = distribuicoes[5],
          method = optimizadores[2],
          itnmax = 10000,
          disp = list(100))


annual_biomass =
  CatDynBSD(fit_null$fit,
            method = names(fit_null$fit$Model),
            multi = T,
            mbw.sd = predicos$se.fit) %>% 
  mutate(TimeStep = 180,
         x =seq(2006,2020+11/12,1/12)) 

catch_cat = unlist(CatDynPred(x=fit_null$fit,method="spg")$Model$Results['Predicted.Catch.thou'])
cat_pars_1 = fit_null$fit$Model$spg$bt.par


results = fit_null$pred$Model$Results %>% 
  as.data.frame() %>% 
  mutate(x = 1:180)

natural_mortality = fit_null$fit$Model$spg$bt.par$M
natural_mortality_sd = fit_null$fit$Model$spg$bt.stdev[['M']]

f_m = results$`Observed.F.1/month`/(results$`Observed.F.1/month` + natural_mortality)

f_m_p = results$`Predicted.F.1/month`/(results$`Predicted.F.1/month` + natural_mortality)
```

```{r}
#| echo: false

# CatDyn biomass plot

ggplot() + 
  geom_line(aes(x = annual_biomass$x,
                y = annual_biomass$B.ton,
                group = 1),
            size = 1) +
  geom_ribbon(aes(x = annual_biomass$x,
                  y = annual_biomass$B.ton,
                  ymin= annual_biomass$B.ton- 2*annual_biomass$B.ton.SE*0,
                  ymax= annual_biomass$B.ton+ 2*annual_biomass$B.ton.SE*0),
              alpha=0.4) +
 theme_bw()
```

```{r}
#| echo: false

# CatDyn mortality plot

results %>% 
  ggplot() + 
  geom_line(aes(x = Period.month,
                y = `Observed.F.1/month`),
            col = 'tomato',
            size = 1) +
  geom_line(aes(x = Period.month,
                y = `Predicted.F.1/month`),
            col = 'darkred',
            size = 1,
            linetype = 2) + 
  geom_hline(yintercept = natural_mortality,
             col = 'darkgreen',
             size = 1,
             linetype = 1) +
  geom_hline(yintercept = natural_mortality + 2*natural_mortality_sd,
             col = 'darkgreen',
             size = 1,
             linetype = 2) +
  geom_hline(yintercept = natural_mortality - 2*natural_mortality_sd,
             col = 'darkgreen',
             size = 1,
             linetype = 2) +
  theme_bw()
```


```{r}
#| echo: false

# CatDyn exploitation plot
  
  # coord_cartesian(ylim = c(0, 300000), xlim = c(1995,2024)) +
  # theme_bw()

results %>% 
  ggplot() + 
  geom_line(aes(x = Period.month,
                y = f_m),
            col = 'tomato',
            size = 1) +
  
  geom_line(aes(x = Period.month,
                y = f_m_p),
            col = 'darkred',
            size = 1,
            linetype = 2) + 
  geom_hline(yintercept = 0.4) + 
  # geom_line(aes(x = Period.month,
  #               y = `Observed.F.1/month`/(`Observed.F.1/month`+ natural_mortality)),
  #           col = 'purple',
  #           size = 1) +
  # geom_hline(yintercept = 0.4,
  #            col = 'darkgreen',
  #            size = 1,
  #            linetype = 1) +
  theme_bw()
```


# RTMB


## Parameters to be estimated

-   $\alpha$ is the abundance response

-   $\beta$ is the effort response

Both allow non-linearity for $E_t$ and $N_t$;

-   $k$ is a scaling factor

-   $M$ is the natural mortality (with $m = e^{-\frac{M}{2}}$)

-   $N_0$ is the initial abundance of the stock at $t_0$

-  $R_j$ are the recruitment pulse magnitudes

## Model 3.1: GDM, as seen on CatDyn


```{r}
#| results: hide
#| warning: false
#| echo: false

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par # already defined on catdyn chunk

# initialize joint negative loglikelihood function

jnll = function(par) {
  getAll(par, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K      = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj = MakeADFun(jnll, par)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

lower <- list(
  logRt_scaled = rep(Rt_min, 9),
  logalpha = -10, logbeta = -10, logK = -10,
  logN0_scaled = -10, logM = -10, logsdCt = -10
)

upper <- list(
  logRt_scaled = rep(Rt_max, 9),
  logalpha = 10, logbeta = 10, logK = 10,
  logN0_scaled = 10, logM = 10, logsdCt = 10
)

# Run optimizer
fit_nlmimb = nlminb(obj$par, obj$fn, obj$gr)
fit_nlmimb_nogr = nlminb(obj$par, obj$fn, NULL)
# lower = unlist(lower),
# upper = unlist(upper))

spg1 = optimx(par = obj$par,
             fn = obj$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)




# Retrieve predicted catch
predicted_catch = obj$report()$predcat
sdr = sdreport(obj)
pl = as.list(sdr,"Est")
plsd = as.list(sdr,"Std")


```

```{r}
#| echo: false

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```


```{r}
#| echo: false
#| results: hide

# report from catdyn
fit_null$fit$Model$spg

report_manual(p = 15,
              method = 'spg',
              opt_result = spg1,
              dates=c(1,dat$u,length(dat$Ct)),
              distr = 'aplnormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par)

catdynpred <- CatDynPred(x=fit_null$fit,method="spg")
predicted_catch = obj$report()$predcat #RTMB


cat_pars_1 = fit_null$fit$Model$spg$bt.par
```


```{r}
#| output: asis
#| echo: false
#| cap-location: top

xtable(data.frame(
                  alpha = c(cat_pars_1$`alpha.MIS+OTB-S`, exp(spg1['logalpha']) %>% unlist,
                            exp(fit_nlmimb$par['logalpha']),  exp(fit_nlmimb_nogr$par['logalpha'])),
                  beta = c(cat_pars_1$`beta.MIS+OTB-S`, exp(spg1['logbeta'])%>% unlist,
                           exp(fit_nlmimb$par['logbeta']),  exp(fit_nlmimb_nogr$par['logbeta'])),
                  k = c(cat_pars_1$`k.MIS+OTB-S`,  exp(spg1['logK'])%>% unlist,
                        exp(fit_nlmimb$par['logK']),  exp(fit_nlmimb_nogr$par['logK'])),
                  M = c(cat_pars_1$`M`,  exp(spg1['logM'])%>% unlist,
                        exp(fit_nlmimb$par['logM']),  exp(fit_nlmimb_nogr$par['logM'])),
                  N0 = c(cat_pars_1$N0,  exp(spg1['logN0_scaled'])%>% unlist,
                         exp(fit_nlmimb$par['logN0_scaled']),  exp(fit_nlmimb_nogr$par['logN0_scaled'])),
                  SD_Ct = c("NA", exp(spg1["logsdCt"])%>% unlist,
                            exp(fit_nlmimb$par['logsdCt']),  exp(fit_nlmimb_nogr$par['logsdCt'])),
                  R1 = c(cat_pars_1$`P1.MIS+OTB-S`,spg1[1]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[1]),  exp(fit_nlmimb_nogr$par[1])),
                  R2 = c(cat_pars_1$`P2.MIS+OTB-S`,spg1[2]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[2]),  exp(fit_nlmimb_nogr$par[2])),
                  R3 = c(cat_pars_1$`P3.MIS+OTB-S`,spg1[3]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[3]),  exp(fit_nlmimb_nogr$par[3])),
                  R4 = c(cat_pars_1$`P4.MIS+OTB-S`,spg1[4]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[4]),  exp(fit_nlmimb_nogr$par[4])),
                  R5 = c(cat_pars_1$`P5.MIS+OTB-S`,spg1[5]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[5]),  exp(fit_nlmimb_nogr$par[5])),
                  R6 = c(cat_pars_1$`P6.MIS+OTB-S`,spg1[6]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[6]),  exp(fit_nlmimb_nogr$par[6])),
                  R7 = c(cat_pars_1$`P7.MIS+OTB-S`,spg1[7]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[7]),  exp(fit_nlmimb_nogr$par[7])),
                  R8 = c(cat_pars_1$`P8.MIS+OTB-S`,spg1[8]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[8]),  exp(fit_nlmimb_nogr$par[8])),
                  R9 = c(cat_pars_1$`P9.MIS+OTB-S`,spg1[9]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[9]),  exp(fit_nlmimb_nogr$par[9])),
                  R10 = c(cat_pars_1$`P10.MIS+OTB-S`,spg1[10]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[10]),  exp(fit_nlmimb_nogr$par[10])),
                  R11 = c(cat_pars_1$`P11.MIS+OTB-S`,spg1[11]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[11]),  exp(fit_nlmimb_nogr$par[11])),
                  R12 = c(cat_pars_1$`P12.MIS+OTB-S`,spg1[12]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[12]),  exp(fit_nlmimb_nogr$par[12])),
                  R13 = c(cat_pars_1$`P13.MIS+OTB-S`,spg1[13]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[13]),  exp(fit_nlmimb_nogr$par[13])),
                  R14 = c(cat_pars_1$`P14.MIS+OTB-S`,spg1[14]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[14]),  exp(fit_nlmimb_nogr$par[14])),
                  R15 = c(cat_pars_1$`P15.MIS+OTB-S`,spg1[15]%>% unlist %>% exp,
                         exp(fit_nlmimb$par[15]),  exp(fit_nlmimb_nogr$par[15])),
                  row.names = c('CatDyn', 'RTMB_spg','RTMB_nlmimb', 'RTMB_nlmimb_nogradient')) %>% t, digits = 8) %>%
  print(comment = F,
        sanitize.text.function = function(x)
          {gsub("_", "\\\\_", x)})


```

```{r}
#| echo: false
ggplot() + 
  geom_line(aes(x = 1:180,
                y = unlist(catdynpred$Model$Results['Predicted.Catch.thou']))) +   
  geom_line(aes(x = 1:180,
                y = predicted_catch), col = 'red') + 
  theme_bw() + 
  labs(y = 'catch', title = 'Catdyn (black), RTMB (red)')
```



## RTMB With $K(t)$

```{r}
#| results: hide
#| warning: false
#| echo: false

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)
nS = ceiling(nT/12) # of seasons

season = matrix(0, nrow = nT, ncol = nS)
for (j in 1:nS) {
  season[(j-1) * 12  + (1:12), j] <- 1 # .
}  

I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I
dat$season = season

# Initial parameter values
par_kt = par # already defined on catdyn chunk
par_kt$logkt = rep(par$logK, ceiling(nT/12))

# initialize joint negative loglikelihood function

jnll_kt = function(par_kt) {
  getAll(par_kt, dat)


  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  Kt     = exp(logkt)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
  
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) 
      mccum[i] * exp(-M/2)
    
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- season[i, ceiling(i/12)] * Kt * (effeff1 * effn1) * exp(-M/2)
    # season_i <- ceiling(i / 12)
    # season_i <- min(season_i, length(Kt))  # safety check

    # effeff1 <- Et[i]^alpha
    # effn1   <- nstep[i]^beta
    # 
    # predcat[i] <- Kt[season_i] * effeff1 * effn1 * exp(-M/2)
    }
  
  # Negative log-likelihood
  jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(Kt)
    REPORT(nstep)
  jnll

}

# quick test: do we get a number? This number should be a likelihood.
jnll_kt(par_kt)

obj_kt = MakeADFun(jnll_kt, par_kt)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

lower <- list(
  logRt_scaled = rep(Rt_min, 9),
  logalpha = -10, logbeta = -10, logK = -10,
  logN0_scaled = -10, logM = -10, logsdCt = -10
)

upper <- list(
  logRt_scaled = rep(Rt_max, 9),
  logalpha = 10, logbeta = 10, logK = 10,
  logN0_scaled = 10, logM = 10, logsdCt = 10
)

# Run optimizer
fit_nlmimb_kt = nlminb(obj_kt$par, obj_kt$fn, obj_kt$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_kt = optimx(par = obj_kt$par,
             fn = obj_kt$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)



obj_kt$report()$Kt
obj_kt$report()$nstep
obj_kt$report()$predcat

# Retrieve predicted catch
predicted_catch_kt = obj_kt$report()$predcat
sdr_kt = sdreport(obj_kt)
pl_kt = as.list(sdr_kt,"Est")
plsd_kt = as.list(sdr_kt,"Std")


```


```{r}
#| echo: false

# results from RTMB catch prediction 

ggplot() + 
  geom_line(aes(x = 1:length(dat$Ct),
                y = catch_cat)) + 
   geom_line(aes(x = 1:length(dat$Ct),
                y = predicted_catch_kt), col = 'red') +
     geom_line(aes(x = 1:length(dat$Ct),
                y = dat$Ct), linetype = 'dashed')
```

## RTMB With $alpha(t)$

```{r}
#| results: hide
#| warning: false
#| echo: false

nmult = 1e3
dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par_at = par # already defined on catdyn chunk
par_at$logalpha = rep(par$logalpha, ceiling(nT/12))

# initialize joint negative loglikelihood function

jnll_at = function(par_at) {
  getAll(par_at, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K     = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    season = ceiling(i/12)
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(dat$u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha[season])
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  jnll = -sum(dnorm(log(Ct), mean = log(predcat), sd = logsdCt, log = TRUE))
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
    REPORT(alpha)
    REPORT(nstep)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll_at(par_at)

obj_at = MakeADFun(jnll_at, par_at)

# Set bounds

Rt_min = 0      # recruitment can't be negative
Rt_max = 1e8

# lower <- list(
#   logRt_scaled = rep(Rt_min, 9),
#   logalpha = -10, logbeta = -10, logK = -10,
#   logN0_scaled = -10, logM = -10, logsdCt = -10
# )
# 
# upper <- list(
#   logRt_scaled = rep(Rt_max, 9),
#   logalpha = 10, logbeta = 10, logK = 10,
#   logN0_scaled = 10, logM = 10, logsdCt = 10
# )

# Run optimizer
fit_nlmimb_at = nlminb(obj_at$par, obj_at$fn, obj_at$gr)

# lower = unlist(lower),
# upper = unlist(upper))

spg1_at = optimx(par = obj_at$par,
             fn = obj_at$fn,
             gr = NULL,
             method = 'spg',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)



obj_at$report()$alpha
obj_at$report()$nstep
obj_at$report()$predcat

# Retrieve predicted catch
predicted_catch_at = obj_at$report()$predcat
sdr_at = sdreport(obj_at)
pl_at = as.list(sdr_at,"Est")
plsd_at = as.list(sdr_at,"Std")


```
\todo[inline]{NaN warnings were also produced here}


\begin{abstract}

Polvo e o caralho (\cite{alemany_bayesian_2017})


\begin{keywords}
Bayesian, parametric, $p$-value, ICES
\end{keywords}
\end{abstract}



\section{Introduction\label{intro}}

This is sample text and needs to be completely replaced before submitting your paper.

\section{Methodology}

This work aims to reproduce the work first presented in [trabalho do isco].

Data was provided bt DGRM. It spans the years of 2005 to 2020. Like the reference work, landings and effort from the polyvalent and bottom trawl fleets were included since no significant differences between their catch and effort relationship were observed. In this fashion, captures from near shore and coast fisheries were accounted for.

Due to the defesation, september of 2016 had catch 0, which caused a failure in the numerical methods of the optimization process. An arbitrary 0.01 kg were added to the catch of octopus in this month.





\section{References}

References within your paper should use the Harvard referencing format. This is sample text and needs to be completely replaced before submitting your paper. 

\subsection{Secondary Subhead}


This is sample text and needs to be completely replaced before submitting your paper.   

\section{Another Primary Subhead}

\subsection{Secondary Subhead}

This is sample text and needs to be completely replaced before submitting your paper. 

\subsubsection{Tertiary Subhead}

This is sample text and needs to be completely replaced before submitting your paper. 

\begin{table}
\caption{Genotypes and Their Genotypic Values for a Diallelic Locus Genotypes and Their Genotypic Values for a Diallelic Locus Genotypes and Their Genotypic Values for a Diallelic Locus Genotypes and Their Genotypic Values for a Diallelic Locus Genotypes and Their Genotypic Values for a Diallelic Locus }
\begin{center}
\begin{tabular}{ccccc}
\hline
\hline
\\[-5pt]
\multicolumn{2}{c}{Genotype} & &
\multicolumn{1}{c}{Dummy for additivity} &
\multicolumn{1}{c}{Dummy for dominance }\\
\multicolumn{1}{c}{Label} &    
\multicolumn{1}{c}{Index i} &
\multicolumn{1}{c}{Genotypic value ($\eta$)}&
\multicolumn{1}{c}{effect $\alpha$ (x)} &
\multicolumn{1}{c}{effect $\delta$ (z)}\\
\hline
qq      &1&     $\mu + \mbox{2}\alpha$  & 2&    0\\
Qq&     2&      $\mu + \alpha + \delta$&        1       &1\\
QQ&     3&      $\mu$&  0&      0\\
\hline
\end{tabular}
\end{center}
\end{table}

This is sample text and needs to be completely replaced before submitting your paper. 

\begin{figure}[t]
\centering\includegraphics[scale=.75]{fig1.JPG}
\caption{Place figure caption here.}
\end{figure}

This is sample text and needs to be completely replaced before submitting your paper. 