---
title: "CatDyn to RTMB"
subtitle: "Some notes on porting functionality between the 2 methodologies"
format:
   pdf:
       include-in-header:
           - text: |
                \usepackage{todonotes}
                \usepackage{graphicx}
                \usepackage{amsmath}
                \usepackage{fvextra}
                \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
editor: source
documentclass: asaproc
tbl-cap-location: top
classoption: 11pt
cite-method: biblatex
bibliography: Polvices.bib
biblatexoptions: 
  - citestyle=authoryear
author:
  - name: "Alberto Rocha \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: true
  - name: "Diana Feijó \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: false   
  - name: "Ana Moreno \\thanks{Instituto Português do Mar e da Atmosfera}"
    corresponding: false
number-sections: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| eval: false
#| echo: false
#| include: false
tinytex::parse_install("report.log")
tinytex::tlmgr_update()


# https://cameronpatrick.com/post/2023/07/quarto-thesis-formatting/
```

```{r setup}
#| include: false

library(gridExtra)
library(CatDyn)
library(RTMB)
library(wesanderson)
library(tidyverse)
library(xtable)
library(tmbstan)
library(shinystan)
library(optimx)

source('scripts/custom_catdyn_fit.R')
source('scripts/custom_catdyn_bsd.R')
source('scripts/funcoes_catdyn.R')
source('WS/CatDynBSD9P.R')

load("data/df_effort_m_mbw_otb.Rdata")
load('data/mbw_model.Rdata')

mod_aux = lm(df_effort$catch ~ df_effort$effort)

# Fix a couple of outliers
df_effort = 
  df_effort %>% 
  mutate(catch = case_when(year_sale == 2005 &
                             month_sale == '09' ~
                             effort * mod_aux$coefficients[2] +
                             mod_aux$coefficients[1],
                           T ~ catch),
         catch_otb = case_when(year_sale == 2005 &
                                 month_sale == '09' ~
                                 effort_otb * mod_aux$coefficients[2] +
                                 mod_aux$coefficients[1],
                               T ~ catch_otb)) %>% 
  mutate(catch_otb = case_when(catch_otb == 0 ~ mean(catch_otb), 
                               T ~ catch_otb),
         effort_otb = case_when(effort_otb  < 150 ~ mean(effort_otb),
                                T ~ effort_otb))

# function for manual catdyn report
report_manual = function(p, method, dates,
                         distr, fleet.name, par.tmp,
                         opt_result){
  results2 = vector("list", length(method))
      names(results2) = method
      temp = attr(opt_result, "details")
      for (i in 1:length(method)) {
        results2[[i]]$Type <- p
        results2[[i]]$Dates <- dates
        names(results2[[i]]$Dates) <- c("ts.start",
                                        paste0('ts.', seq(1:p)),
                                        "ts.end")
        results2[[i]]$Distr <- distr
        par.names <- c("M", "N0", paste0('P', seq(1:p), ".", rep(fleet.name,p)),
                       paste(c("k.", "alpha.", "beta."), fleet.name, sep = ""))
        
        if (distr %in% c("negbin", "normal" ,
                         "lognormal",  "gamma",
                         "roblognormal", "gumbel")) {
          par.names <- c(par.names, paste("psi.", fleet.name, 
            sep = ""))
        }
        
        results2[[i]]$converg <- "FAIL"
        results2[[i]]$kkt <- NA
        results2[[i]]$AIC <- NA
        results2[[i]]$bt.par <- NA
        results2[[i]]$num.grads <- NA
        results2[[i]]$bt.stdev <- NA
        results2[[i]]$Cor <- matrix(NA, length(par.names), 
          length(par.names))
        
        if (length(temp[i, ]$ngatend) == length(par.names) & 
          !any(is.na(temp[i, ]$nhatend)) & 1/kappa(temp[i, 
          ]$nhatend) > 1e-15) {
          results2[[i]]$converg <- opt_result[i, length(par.tmp) + 
            5]
          results2[[i]]$kkt <- opt_result[i, (length(par.tmp) + 
            6):(length(par.tmp) + 7)]
          results2[[i]]$AIC <- 2 * length(par.tmp) + 2 * 
            opt_result[i, length(par.tmp) + 1]
          results2[[i]]$bt.par <- exp(opt_result[i, (1:length(par.tmp))])
          results2[[i]]$num.grads <- temp[i, ]$ngatend
          
          v <- matrix(0, length(par.names), length(par.names))
          
          if (distr %in% c("poisson",  "apnormal", "aplnormal")) {
            v <- deltamethod(
    g = lapply(paste0('~exp(x', 1:length((par.tmp)-1), ')'), as.formula),
    mean = as.numeric(opt_result[i, 1:length((par.tmp)-1)]),
    cov = try(solve(temp[i, ]$nhatend)),
    ses = FALSE
)
          }
          else {
            v <- deltamethod(
            g = lapply(paste0('~exp(x', seq_along(par.tmp), ')'), as.formula),
            mean = as.numeric(opt_result[i, 1:length(par.tmp)]),
            cov = try(solve(temp[i, ]$nhatend)),
            ses = FALSE
)
          }
          results2[[i]]$bt.stdev <- sqrt(diag(v))
          results2[[i]]$Cor <- cor(v)
          names(results2[[i]]$num.grads) <- par.names
          names(results2[[i]]$bt.par) <- par.names
          names(results2[[i]]$bt.stdev) <- par.names
          colnames(results2[[i]]$Cor) <- par.names
          rownames(results2[[i]]$Cor) <- par.names 
        } else {print('convergencia e meio merdosa')}}
        return(results2)}      
```


# Introduction
Multi-annual generalized depletion models (MAGD) currently available in the package *CatDyn* rank among the most interesting and promising tools for stock assessment. These models focus on modelling catch dynamics (hence the name) and can serve as a solid base for estimates for biomass assessment models. In the current version of the package, they suffer from a series of constraints caused by the structure of the package that limits their applicability. The goal of this report is to document the transition of the *CatDyn* workflow to a more generalized *RTMB* approach.  

Throughout this document, two example datasets will be used. Both datasets were presented by the $CatDyn$ package author during a workshop on this methodology. They will be reffered throughout the document as dataset 1 (regarding a blue shark fishery) and dataset 2 (concerning a lobster fishery). 

## The moving pieces in *CatDyn*

In *CatDyn*, we model catch dynamics, instead of stock biomass dynamics. The core formulation is as such:

\begin{equation}
    \begin{aligned}
    \label{eq:catdyn_1}
C_t = kE_t^\alpha  N_t ^ \beta
    \end{aligned}
\end{equation}

Where $k$ is a constant for scaling, $E_t$ recorded effort at timestep $t$ and $N_t$ biomass (in numbers) at timestep $t$. While $E_t$ consists of observations, $N_t$ must be estimated for each timestep. In discrete time, the model becomes

@TODO alpha
@TODO beta

\begin{equation}
    \begin{aligned}
    \label{eq:catdyn_2}
C_t = kE_t^\alpha  m \left( N_0 e^{-Mt} -m \left[ \sum_{i=i}^{i=t-1} C_{i,i} e^{-M(t-i-1)} \right] + \sum_{j=1}^{j=u} I_j R_j e^{-M(t-\tau_j)} - \sum_{l=1}^{l=v} J_l S_l e^{-M(t-\upsilon_l} \right) ^ \beta
    \end{aligned}
\end{equation}

In this version, $N_t^\beta$ is replaced by $m \cdot N(t, ...)^\beta$ where $N(t)$, the estimate of number of individuals alive at time $t$ is a function $f(t, N_0, M, I, R, J, S, u, v, \tau, \upsilon)$. In this approach, some key parameters are introduced:

* $N_0$ is the estimate for the initial estate of the biomass; as we will discuss below, it is an extremely sensitive parameter #TODO terminar

* $M$ is natural mortality rate; a common practice is to get initial values for this parameter from the literature. $m$ evaluates to $e^{\left( - \frac{M}{2} \right)}$ and is a correction used in some components of the model to make the catch happen at the middle of the time step.

* $R_u$ and $S_v$ are vectors of perturbation amplitudes at time steps $u$ and $v$. $u$ and $v$ are input as vectors of perturbation timings. A big part of the fitting process involves deciding the timing of the perturbations by visual inspection of the data series, manually creating the timing vectors $u$ and $v$ and determining initial estimates for perturbation amplitudes in the vectors $R$ and $S$. In this context, positive perturbations can correspond to events such as recruitment pulses and imigration fluxes and negative perturbations can be associated with emigration events.

* $I_j$ and $J_l$ and index matrices, that according to the documentation take the value of 0 when the timestep being evaluated is earlier than the perturbation index and 1 afterwards. This would act as a switch for the perturbations. We will discuss the nuances of the implementation of these matrices below.

## Current limitations in *CatDyn*.
While *CatDyn*, as of version 1.1-1, is a fantastical piece of software, it suffers from some limitations that could be adressed by a diferent approach to implementation:

### Hard limit on the series size
*CatDyn* takes the number of fishing seasons in the data (encoded internally as $p$) and uses it to select a variation of the optimization code suited for that number of parameters to be estimated. Each of these variations was adapted from a common template by hand in what we can only assume to be an extremely tedious and laborious process. The author decided to stop at a maximum of 25 fishing seasons. Because scenarios with transit require their own functions (signaled by the user by passing $p$ as a negative number), this required the preparation of 50 distinct optimization and report functions. This approach also forces the exclusion of scenarios where the number of positive pulses in abundance (*ie* recruitment) and negative pulses (*ie* migrations) differ.

### Limit on the number of fleets
*CatDyn* allows for the incorporation of 2 distinct fleets operating in the fishery, each being modeled with their on estimates for $K_f$, $\alpha_f$, $\beta_f$, $R_{u,f}$ and $S_{v,}f$, with shared estimates for $N_0$ and $M$. These estimates are derived from separate $C_{t,f}$ and $E_{t,f}$ data series. Like the previous example, accounting for 1 and 2 fleet scenarios required a set of functions for each instance, raising the total variations to 100 so far.

### Alternate formulations and time-dependent parameters
The current implementation relies on a fixed formulation of the objective function that does not allow $K$, $\alpha$, $\beta$ or $M$ to change over time, nor the inclusion of more parameters. While a case could be made that such inclusions would be either overkill or lead to overfitting and problematic convergences, a reimplementation in $RTMB$ makes such adjustments very easy to make.

## Challenges in transposition

### Adjusted profiles for likelihood functions
In the theoretical framework behind the implementation of MAGD in *CatDyn*, it is proposed the use of adjusted likelihood functions for normal and lognormal distributions were the dispersion parameter is removed in order to facilitate the estimation process. Custom likelihood functions have historically been problematic in TMB (as of today, *dgamma()* is still broken) so porting this functionality is not guaranteed to work.

# Functionality

## Objective function

The objective function constitutes the calculation of the mean of the statistical process that is being modeled, and is the basis against which the parameters are optimized. According to several papers published by the author, the process models catch at time $t$, $C_t$ and was already described in \ref{eq:catdyn_2}:



In $R$, the objective function is stated both in the *CatDynExp()* and in the several .CDMN auxiliary functions. No differences were detected in the implementations on each case, and it can be abbreviated as such: 

```{r}
#| eval: false
  mccum[1] = 0
  nstep[1] = N0 * exp(-M)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
```

Which could be synthesized as:

\begin{equation}
\begin{aligned}
\text{mccum}_1 &= 0 \\
n_{\text{step},1} &= N_0 \cdot e^{-M} \\
\text{mccum} &= \sum_{i=2}^{n_T} C_{i-1} + \text{mccum}_{i-1} \cdot e^{-M} \\
\text{for } i &= 2 \text{ to } n_T: \\
n_{\text{step},i} &= N_0 \cdot e^{-Mi} + \sum_{u} I_{i,u} \cdot R_t \cdot e^{-M(i - (u - 1) + 1)} - \text{mccum}_i \cdot e^{-M/2} \\
\text{predcat} &= K \cdot  E_t^\alpha \cdot n_{\text{step}}^\beta \cdot e^{-M/2}
\end{aligned}
\end{equation}

Despite the differences in the indexation, it can be shown that this objective function and *CatDynPred()* (and later *CatDynFit()*) are numerically equivalent: First we load the data:

```{r}
#| echo: false
# Blue shark example
tibec.14.22.pg.1 <- read.csv("WS/tibec.14.22.pg.1.csv",header=TRUE)

tibec.14.22.pg.2 = as.CatDynData(x=tibec.14.22.pg.1,
                                  step="month",
                                  fleet.name=c("Pelagic"),
                                  coleff=4,
                                  colcat=3,
                                  colmbw=5,
                                  unitseff="ntrips",
                                  unitscat="kg",
                                  unitsmbw="kg",
                                  nmult="thou",
                                  season.dates=c("2014-01-01","2022-12-31"))


# Lobster example
cateff1.Crusoe <- read.csv("WS/RobinsonCrusoeLobster.csv",header=TRUE)
#
################################################################################
# 2.- Stock assessment                                                         #
################################################################################
#
################################################################################
# 2.1.- Robinson Crusoe                                                        #
################################################################################
#
################################################################################
# 2.1.1.- Depletion models season: 2002-2003                                   #
################################################################################
#
# Data object
jflcrusoe0203  <- as.CatDynData(x=cateff1.Crusoe[cateff1.Crusoe$Season==1,],
                                step="week",
                                fleet.name="nasas",
                                coleff=4,
                                colcat=5,
                                colmbw=6,
                                unitseff="ndays",
                                unitscat="kg",
                                unitsmbw="g",
                                nmult="thou",
                                season.dates=c("2002-09-28","2003-05-22"))
```

Then we can compare both approaches:

```{r blueshark}
#| echo: false
P1.Pelagic  <- 12  #2014
P2.Pelagic  <- 24  #2015
P3.Pelagic  <- 36  #2016
P4.Pelagic  <- 47  #2017 
P5.Pelagic  <- 60  #2018 
P6.Pelagic  <- 72  #2019
P7.Pelagic  <- 84  #2020 
P8.Pelagic  <- 96  #2021
P9.Pelagic  <- 107 #2022
#
tibec.14.22.pg.dates.1  <- c(head(tibec.14.22.pg.2$Data[[1]]$time.step,1),
                             P1.Pelagic,
                             P2.Pelagic,
                             P3.Pelagic,
                             P4.Pelagic,
                             P5.Pelagic,
                             P6.Pelagic,
                             P7.Pelagic,
                             P8.Pelagic,
                             P9.Pelagic,
                             tail(tibec.14.22.pg.2$Data[[1]]$time.step,1))

M.ini             <- 0.015
N0.ini            <- 500
P1.ini.Pelagic    <- 100 #12  2014
P2.ini.Pelagic    <- 50  #24  2015
P3.ini.Pelagic    <- 50  #36  2016
P4.ini.Pelagic    <- 50  #47  2017
P5.ini.Pelagic    <- 100 #60  2018
P6.ini.Pelagic    <- 60  #72  2019
P7.ini.Pelagic    <- 350 #84  2020
P8.ini.Pelagic    <- 150 #96  2021
P9.ini.Pelagic    <- 150 #107 2022
k.ini.Pelagic     <- 2e-6
alpha.ini.Pelagic <- 1
beta.ini.Pelagic  <- 1
#
psi.ini.Pelagic    <- 0.25*sd(tibec.14.22.pg.2$Data$Pelagic$obscat.thou[
  tibec.14.22.pg.2$Data$Pelagic$obscat.thou>0])^2
psilog.ini.Pelagic <- 0.25*sd(log(tibec.14.22.pg.2$Data$Pelagic$obscat.thou[
  tibec.14.22.pg.2$Data$Pelagic$obscat.thou>0]))^2

tibec.14.22.pg.pars.ini <- log(c(M.ini,
                                 N0.ini,
                                 P1.ini.Pelagic,
                                 P2.ini.Pelagic,
                                 P3.ini.Pelagic,
                                 P4.ini.Pelagic,
                                 P5.ini.Pelagic,
                                 P6.ini.Pelagic,
                                 P7.ini.Pelagic,
                                 P8.ini.Pelagic,
                                 P9.ini.Pelagic,
                                 k.ini.Pelagic,
                                 alpha.ini.Pelagic,
                                 beta.ini.Pelagic,
                                 psi.ini.Pelagic))
#



tibec.14.22.pg.ini.apn <- catdynexp(x=tibec.14.22.pg.2,                                 
                                    p=9,
                                    par=tibec.14.22.pg.pars.ini[1:15],
                                    dates=tibec.14.22.pg.dates.1,
                                    distr="normal")


simul_catdyn = tibec.14.22.pg.ini.apn$Model$Results$Predicted.Catch.thou

#################################################

Ct = as.vector(tibec.14.22.pg.2$Data$Pelagic$obscat.thou)         # observed catch
Et = as.vector(tibec.14.22.pg.2$Data$Pelagic$obseff.ntrips)       # effort
u = c(12, 24, 36, 47, 60, 72, 84, 96, 107)                        # recruitment pulse months
nT = length(Ct)
nR = length(u)
I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}
Rt = c(P1.ini.Pelagic,P2.ini.Pelagic,
      P3.ini.Pelagic,P4.ini.Pelagic,
      P5.ini.Pelagic, P6.ini.Pelagic,
      P7.ini.Pelagic, P8.ini.Pelagic,
      P9.ini.Pelagic)

nstep <- vector("numeric", nT) * alpha.ini.Pelagic #init vector
mccum = vector("numeric", nT) * alpha.ini.Pelagic 
effeff1 = vector("numeric", nT) * alpha.ini.Pelagic 
effn1 = vector("numeric", nT) * alpha.ini.Pelagic 
predcat = vector("numeric", nT) * alpha.ini.Pelagic 


    mccum[1] = 0
  nstep[1] = N0.ini * exp(-M.ini)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M.ini)
    nstep[i] = N0.ini * exp(-M.ini*i) + 
      sum(I[i,] * Rt * exp(-M.ini*(i-(u-1)+1))) -
      mccum[i] * exp(-M.ini/2)
    effeff1 <- Et^(alpha.ini.Pelagic )
    effn1 <- nstep^(beta.ini.Pelagic )
    predcat = k.ini.Pelagic  * (effeff1 * effn1) * exp(-M.ini/2)
  }
  
  
ggplot() + 
  geom_line(aes(x = 1:108,
                y = simul_catdyn),
            linewidth = 1.5) + 
  # geom_line(aes(x = 1:108,
  # y = rnorm(108,catch,sdCt)), col = 'red') + 
  geom_line(aes(x = 1:108,
                y = predcat), col = 'red',
            linetype = 'dashed', linewidth = 1.5) + 
  labs(title = "CatDyn (black) and custom objective function (red dashed)") + 
  theme_bw()
  
```

```{r lobster}
M.ini       <- 10*0.001937482
N0.ini      <- 3*9.210188
P1.ini      <- 45
P2.ini      <- 20
k.ini       <- 8.5e-4                                                           # always between 1e-3 and 1e-6
alpha.ini   <- 1                                                                # always close to 1
beta.ini    <- 1                                                                # always close to 1
psi.ini = 0.25*sd(jflcrusoe0203$Data$nasas$obscat.thou[jflcrusoe0203$Data$nasas$obscat.thou>0])^2
pars.ini.2P <- log(c(M.ini,N0.ini,P1.ini,P2.ini,k.ini,alpha.ini,beta.ini, psi.ini))
#
dates.2P    <- c(head(jflcrusoe0203$Data$nasas$time.step,1),                   # now the dates vector also has
                 41,
                 49,                                                            # the week of one input of abundance
                 tail(jflcrusoe0203$Data$nasas$time.step,1))
#
# jfldesvent1112.2P.apn.ini <- catdynexp(x=jflcrusoe0203,
#                                        p=2,
#                                        par=pars.ini.2P,
#                                        dates=dates.2P,
                                       # distr="normal")
#


jfldesvent1112.2P.1.apn.exp  <- catdynexp(x=jflcrusoe0203,
                                          p=2,
                                          par=pars.ini.2P,
                                          dates=dates.2P,
                                          distr="normal")

simul_catdyn = jfldesvent1112.2P.1.apn.exp$Model$Results$Predicted.Catch.thou

#################################################


Ct = as.vector(jflcrusoe0203$Data$nasas$obscat.thou)         # observed catch
Et = as.vector(jflcrusoe0203$Data$nasas$obseff.ndays)       # effort
u = c(41,49) - jflcrusoe0203$Data$nasas$time.step[1] + 1                       # recruitment pulse months
nT = length(Ct)
nR = length(u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}


Rt = c(P1.ini, P2.ini)

nstep <- vector("numeric", nT) * alpha.ini.Pelagic #init vector
mccum = vector("numeric", nT) * alpha.ini.Pelagic 
effeff1 = vector("numeric", nT) * alpha.ini.Pelagic 
effn1 = vector("numeric", nT) * alpha.ini.Pelagic 
predcat = vector("numeric", nT) * alpha.ini.Pelagic 


    mccum[1] = 0
  nstep[1] = N0.ini * exp(-M.ini)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M.ini)
    nstep[i] = N0.ini * exp(-M.ini*i) + 
      sum(I[i,] * Rt * exp(-M.ini*(i-(u-1)+1))) -
      mccum[i] * exp(-M.ini/2)
    effeff1 <- Et^(alpha.ini )
    effn1 <- nstep^(beta.ini )
    predcat = k.ini  * (effeff1 * effn1) * exp(-M.ini/2)
  }
  
  
ggplot() + 
  geom_line(aes(x = 1:36,
                y = simul_catdyn),
            linewidth = 1.5) + 
  # geom_line(aes(x = 1:108,
  # y = rnorm(108,catch,sdCt)), col = 'red') + 
  geom_line(aes(x = 1:36,
                y = predcat), col = 'blue',
            linetype = 'dashed', linewidth = 1.5) + 
  labs(title = "CatDyn (black) and custom objective function (blue dashed)") + 
  theme_bw()
```



- Default order is $M$, $N_0$, $R_t$, $k$, $\alpha$, $\beta$ and $\psi$

# Blue Shark Example

## CatDyn (Example from Workshop)

```{r}
#| eval: false
#| results: hide


P1.Pelagic  <- 12  #2014
P2.Pelagic  <- 24  #2015
P3.Pelagic  <- 36  #2016
P4.Pelagic  <- 47  #2017 
P5.Pelagic  <- 60  #2018 
P6.Pelagic  <- 72  #2019
P7.Pelagic  <- 84  #2020 
P8.Pelagic  <- 96  #2021
P9.Pelagic  <- 107 #2022
#
tibec.14.22.pg.dates.1  <- c(head(tibec.14.22.pg.2$Data[[1]]$time.step,1),
                             P1.Pelagic,
                             P2.Pelagic,
                             P3.Pelagic,
                             P4.Pelagic,
                             P5.Pelagic,
                             P6.Pelagic,
                             P7.Pelagic,
                             P8.Pelagic,
                             P9.Pelagic,
                             tail(tibec.14.22.pg.2$Data[[1]]$time.step,1))

M.ini             <- 0.015
N0.ini            <- 500
P1.ini.Pelagic    <- 100 #12  2014
P2.ini.Pelagic    <- 50  #24  2015
P3.ini.Pelagic    <- 50  #36  2016
P4.ini.Pelagic    <- 50  #47  2017
P5.ini.Pelagic    <- 100 #60  2018
P6.ini.Pelagic    <- 60  #72  2019
P7.ini.Pelagic    <- 350 #84  2020
P8.ini.Pelagic    <- 150 #96  2021
P9.ini.Pelagic    <- 150 #107 2022
k.ini.Pelagic     <- 2e-6
alpha.ini.Pelagic <- 1
beta.ini.Pelagic  <- 1
#
psi.ini.Pelagic    <- 0.25*sd(tibec.14.22.pg.2$Data$Pelagic$obscat.thou[tibec.14.22.pg.2$Data$Pelagic$obscat.thou>0])^2
psilog.ini.Pelagic <- 0.25*sd(log(tibec.14.22.pg.2$Data$Pelagic$obscat.thou[tibec.14.22.pg.2$Data$Pelagic$obscat.thou>0]))^2

tibec.14.22.pg.pars.ini <- log(c(M.ini,
                                 N0.ini,
                                 P1.ini.Pelagic,
                                 P2.ini.Pelagic,
                                 P3.ini.Pelagic,
                                 P4.ini.Pelagic,
                                 P5.ini.Pelagic,
                                 P6.ini.Pelagic,
                                 P7.ini.Pelagic,
                                 P8.ini.Pelagic,
                                 P9.ini.Pelagic,
                                 k.ini.Pelagic,
                                 alpha.ini.Pelagic,
                                 beta.ini.Pelagic,
                                 psi.ini.Pelagic))
#



tibec.14.22.pg.ini.apn <- catdynexp(x=tibec.14.22.pg.2,                                 
                                    p=9,
                                    par=tibec.14.22.pg.pars.ini[1:15],
                                    dates=tibec.14.22.pg.dates.1,
                                    distr="normal")

plot(x=tibec.14.22.pg.ini.apn,
     leg.pos="topleft",
     Biom.tstep=1,
     Biom.xpos=0.25,
     Biom.ypos=0.75,
     Cat.tstep=12,
     Cat.xpos=0.25,
     Cat.ypos=0.65)
#
tibec.14.22.pg.apn.1.fit <- CatDynFit(x=tibec.14.22.pg.2,
                                      p=9,
                                      par=tibec.14.22.pg.pars.ini[1:15],
                                      dates=tibec.14.22.pg.dates.1,
                                      distr="normal",
                                      method=c("CG"),
                                      itnmax=50000)
#
tibec.14.22.pg.apn.1.fit.pred.CG <- CatDynPred(x=tibec.14.22.pg.apn.1.fit,method="CG")

x                        <- data.frame(key=rep(1:12,9),
                                       x=tibec.14.22.pg.2$Data$Pelagic$obsmbw.kg)
y                        <- aggregate(x$x,list(x$key),sd)
tibec.14.22.pg.apn.1.bsd <- CatDynBSD9P(x=tibec.14.22.pg.apn.1.fit,
                                        method="CG",
                                        multi=TRUE,
                                        mbw.sd=y$x)

annual_biomass =
tibec.14.22.pg.apn.1.bsd %>% 
  mutate(TimeStep = 108,
         x =seq(2014,2022+11/12,1/12))
```

## RTMB

```{r}
#| results: hide
#| eval: false

dat = list()
dat$Ct = as.vector(tibec.14.22.pg.2$Data$Pelagic$obscat.thou)         # observed catch
dat$Et = as.vector(tibec.14.22.pg.2$Data$Pelagic$obseff.ntrips)       # effort
dat$u = c(12, 24, 36, 47, 60, 72, 84, 96, 107)                        # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par = list(
  logM          = log(M.ini),
  logN0         = log(N0.ini),
  Rt_scaled     = log(c(P1.ini.Pelagic,P2.ini.Pelagic,
                        P3.ini.Pelagic,P4.ini.Pelagic,
                        P5.ini.Pelagic, P6.ini.Pelagic,
                        P7.ini.Pelagic, P8.ini.Pelagic,
                        P9.ini.Pelagic)),
  logK          = log(k.ini.Pelagic),
  logalpha      = log(alpha.ini.Pelagic),
  logbeta       = log(beta.ini.Pelagic),
  logsdCt       = log(psi.ini.Pelagic)
)


Rt_min = 0      # recruitment can't be negative
Rt_max = 1e5    # or some upper limit from prior data or biomass capacit

# initialize joint negative loglikelihood function

jnll = function(par) {
  getAll(par, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K      = exp(logK)
  N0     = exp(logN0)
  M      = exp(logM)
  sdCt   = exp(logsdCt)
  Rt     = exp(Rt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat2 = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  jnll = -sum(dnorm(Ct, mean = predcat, sd = sqrt(sdCt), log = TRUE))
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj7 = MakeADFun(jnll, par)

# Set bounds
lower <- list(
  Rt_scaled = rep(Rt_min, 9),
  logalpha = -10, logbeta = -10, logK = -10,
  logN0_scaled = -10, logM = -10, logsdCt = -10
)

upper <- list(
  Rt_scaled = rep(Rt_max, 9),
  logalpha = 10, logbeta = 10, logK = 10,
  logN0_scaled = 10, logM = 10, logsdCt = 10
)

# Run optimizer
fit7 = nlminb(obj7$par, obj7$fn, obj7$gr,
  # lower = unlist(lower),
  # upper = unlist(upper),
  control = list(iter.max = 50000))

# CG7 <- optim(
#   par = obj7$par,
#   fn = obj7$fn,
#   gr = obj7$gr,
#   method = "CG",
#   control = list(maxit = 1000))

# gradient was set to NULL to match CatDyn approach
CG7 = optimx(par = obj7$par,
             fn = obj7$fn,
             gr = NULL,
             method = 'CG',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)

# report from catdyn
tibec.14.22.pg.apn.1.fit$Model$CG

# report from RTMB
report_manual(p = 9,
              method = 'CG',
              opt_result = CG7,
              dates=tibec.14.22.pg.dates.1,
              distr = 'normal',
              fleet.name = tibec.14.22.pg.2$Properties$Fleets$Fleet,
              par.tmp = tibec.14.22.pg.pars.ini)

# Retrieve predicted catch
predicted_catch = obj7$report()$predcat

```

## Results and Comparison

```{r}
#| output: asis
#| echo: false
#| eval: false
cat_pars_1 = tibec.14.22.pg.apn.1.fit$Model$CG$bt.par

xtable(data.frame(
                  alpha = c(cat_pars_1$alpha.Pelagic, exp(fit7$par['logalpha']), exp(CG7['logalpha']) %>% unlist),
                  beta = c(cat_pars_1$beta.Pelagic, exp(fit7$par['logbeta']), exp(CG7['logbeta'])%>% unlist),
                  k = c(cat_pars_1$k.Pelagic, exp(fit7$par['logK']), exp(CG7['logK'])%>% unlist),
                  M = c(cat_pars_1$M, exp(fit7$par['logM']), exp(CG7['logM'])%>% unlist),
                  N0 = c(cat_pars_1$N0, exp(fit7$par['logN0']), exp(CG7['logN0'])%>% unlist),
                  SD_Ct = c(cat_pars_1$psi.Pelagic, exp(fit7$par["logsdCt"]), exp(CG7["logsdCt"])%>% unlist),
                  R1 = c(cat_pars_1$P1.Pelagic,fit7$par[3],CG7[3]%>% unlist %>% exp),
                  R2 = c(cat_pars_1$P2.Pelagic,fit7$par[4],CG7[4]%>% unlist %>% exp),
                  R3 = c(cat_pars_1$P3.Pelagic,fit7$par[5],CG7[5]%>% unlist %>% exp),
                  R4 = c(cat_pars_1$P4.Pelagic,fit7$par[6],CG7[6]%>% unlist %>% exp),
                  R5 = c(cat_pars_1$P5.Pelagic,fit7$par[7],CG7[7]%>% unlist %>% exp),
                  R6 = c(cat_pars_1$P6.Pelagic,fit7$par[8],CG7[8]%>% unlist %>% exp),
                  R7 = c(cat_pars_1$P7.Pelagic,fit7$par[9],CG7[9]%>% unlist %>% exp),
                  R8 = c(cat_pars_1$P8.Pelagic,fit7$par[10],CG7[10]%>% unlist %>% exp),
                  R9 = c(cat_pars_1$P9.Pelagic,fit7$par[11],CG7[11]%>% unlist %>% exp),
                  row.names = c('CatDyn','RTMB', 'RTMB_CG')) %>% t, digits = 8) %>% 
  print(comment = F,
        sanitize.text.function = function(x)
          {gsub("_", "\\\\_", x)})


                                
check_1cat = 
catdynexp(x=tibec.14.22.pg.2,                                 
      p=9,
      par=log(c(cat_pars_1$M,
      cat_pars_1$N0,
      cat_pars_1$P1.Pelagic,
      cat_pars_1$P2.Pelagic,
      cat_pars_1$P3.Pelagic,
      cat_pars_1$P4.Pelagic,
      cat_pars_1$P5.Pelagic,
      cat_pars_1$P6.Pelagic,
      cat_pars_1$P7.Pelagic,
      cat_pars_1$P8.Pelagic,
      cat_pars_1$P9.Pelagic,
      cat_pars_1$k.Pelagic,
      cat_pars_1$alpha.Pelagic,
      cat_pars_1$beta.Pelagic,
      cat_pars_1$psi.Pelagic)),
      dates=tibec.14.22.pg.dates.1,
      distr="normal")

check_2cat = 
catdynexp(x=tibec.14.22.pg.2,                                 
      p=9,
      par=log(c(exp(fit7$par['logM']),
      exp(fit7$par['logN0']),
      fit7$par[1]%>% exp,
      fit7$par[2]%>% exp,
      fit7$par[3]%>% exp,
      fit7$par[4]%>% exp,
      fit7$par[5]%>% exp,
      fit7$par[6]%>% exp,
      fit7$par[7]%>% exp,
      fit7$par[8]%>% exp,
      fit7$par[9]%>% exp,
      exp(fit7$par['logK']),
      exp(fit7$par['logalpha']),
      exp(fit7$par['logbeta']),
      exp(fit7$par['logsdCt']))),
      dates=tibec.14.22.pg.dates.1,
      distr="normal")

ggplot() + 
  geom_line(aes(x = 1:108,
                y = check_1cat$Model$Results$Predicted.Catch.thou)) + 
  geom_line(aes(x = 1:108,
                y = check_2cat$Model$Results$Predicted.Catch.thou), col = 'red') + 
  theme_bw() + 
  labs(y = 'catch', title = 'Catdyn (black), RTMB (red)')

```

```{r}
#| eval: false
# tibec.14.22.pg.apn.1.fit.pred.CG$Model$Results['Predicted.Catch.thou']
# catch

grid.arrange(

ggplot() + 
  geom_line(aes(x = 1:108,
                y = unlist(tibec.14.22.pg.apn.1.fit.pred.CG$Model$Results['Predicted.Catch.thou']))) + 
  geom_line(aes(x = 1:108,
                y = predicted_catch), col = 'red') + 
  theme_bw() + 
  labs(y = 'catch', title = 'Catdyn (black), RTMB (red)')
,

ggplot() + 
  geom_line(aes(x = 1:9,
                y = unlist(tibec.14.22.pg.apn.1.fit$Model$CG$bt.par[3:11])))+ 
  geom_line(aes(x = 1:9,
                y =  exp(fit7$par[1:9])), col = 'red') + 
    geom_line(aes(x = 1:9,
                y =  exp(par$Rt_scaled)), col = 'green') + 
  theme_bw()+ 
    labs(y = 'Recruitment', title = 'Catdyn (black), RTMB (red), Starting values (green)'),
ncol=1)

```

# Lobster Example

## CatDyn (Example from Workshop)

Estimativas divergiram até baixar N0.ini de 5* para 3*

```{r}
#| eval: false

#
# plot(x=jflcrusoe0203,mark=TRUE,offset=c(9,10),hem="S")                          # 43 51 candidate input weeks
#
# Initial values for 2 input depletion variant
M.ini       <- 10*0.001937482
N0.ini      <- 3*9.210188
P1.ini      <- 45
P2.ini      <- 20
k.ini       <- 8.5e-4                                                           # always between 1e-3 and 1e-6
alpha.ini   <- 1                                                                # always close to 1
beta.ini    <- 1                                                                # always close to 1
psi.ini = 0.25*sd(jflcrusoe0203$Data$nasas$obscat.thou[jflcrusoe0203$Data$nasas$obscat.thou>0])^2
pars.ini.2P <- log(c(M.ini,N0.ini,P1.ini,P2.ini,k.ini,alpha.ini,beta.ini, psi.ini))
#
dates.2P    <- c(head(jflcrusoe0203$Data$nasas$time.step,1),                   # now the dates vector also has
                 41,
                 49,                                                            # the week of one input of abundance
                 tail(jflcrusoe0203$Data$nasas$time.step,1))
#
# jfldesvent1112.2P.apn.ini <- catdynexp(x=jflcrusoe0203,
#                                        p=2,
#                                        par=pars.ini.2P,
#                                        dates=dates.2P,
                                       # distr="normal")
#


jfldesvent1112.2P.1.apn.fit  <- CatDynFit(x=jflcrusoe0203,
                                          p=2,
                                          par=pars.ini.2P,
                                          dates=dates.2P,
                                          distr="normal",
                                          method=c("CG"),
                                          itnmax=50000)


```

## RTMB

```{r}
#| results: hide
#| eval: false
dat = list()
dat$Ct = as.vector(jflcrusoe0203$Data$nasas$obscat.thou)         # observed catch
dat$Et = as.vector(jflcrusoe0203$Data$nasas$obseff.ndays)       # effort
dat$u = c(41,49) - jflcrusoe0203$Data$nasas$time.step[1] + 1                       # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I

# Initial parameter values
par = list(
  logM          = log(M.ini),
  logN0         = log(N0.ini),
  Rt_scaled     = log(c(P1.ini, P2.ini)),
  logK          = log(k.ini),
  logalpha      = log(alpha.ini),
  logbeta       = log(beta.ini),
  logsdCt       = log(psi.ini)  # consistent with CatDyn
)


Rt_min = 0      # recruitment can't be negative
Rt_max = 1e5    # or some upper limit from prior data or biomass capacit

# initialize joint negative loglikelihood function

jnll = function(par) {
  getAll(par, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  = OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  K      = exp(logK)
  N0     = exp(logN0)
  M      = exp(logM)
  sdCt   = exp(logsdCt)
  Rt     = exp(Rt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha


  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- K * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  jnll = -sum(dnorm(Ct, mean = predcat, sd = sqrt(sdCt), log = TRUE))
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll(par)


obj2= MakeADFun(jnll, par)

# Set bounds
# lower <- list(
#   Rt_scaled = rep(Rt_min, 9),
#   logalpha = -10, logbeta = -10, logK = -10,
#   logN0_scaled = -10, logM = -10, logsdCt = -10
# )
# 
# upper <- list(
#   Rt_scaled = rep(Rt_max, 9),
#   logalpha = 10, logbeta = 10, logK = 10,
#   logN0_scaled = 10, logM = 10, logsdCt = 10
# )

# Run optimizer
fit2 = nlminb(obj2$par, obj2$fn, obj2$gr,
  # lower = unlist(lower),
  # upper = unlist(upper),
  control = list(iter.max = 50000))

# CG7 <- optim(
#   par = obj7$par,
#   fn = obj7$fn,
#   gr = obj7$gr,
#   method = "CG",
#   control = list(maxit = 1000))

# gradient was set to NULL to match CatDyn approach
CG2 = optimx(par = obj2$par,
             fn = obj2$fn,
             gr = NULL,
             method = 'CG',
             output = 'estimate',
             hessian = T,
             itnmax = 50000,
             control = list())

# report from catdyn
jfldesvent1112.2P.1.apn.fit$Model$CG
jfldesvent1112.2P.1.apn.fit

# report from RTMB
report_manual(p = 2,
              method = 'CG',
              opt_result = CG2,
              dates=dates.2P,
              distr = 'normal',
              fleet.name = jflcrusoe0203$Properties$Fleets$Fleet,
              par.tmp = pars.ini.2P)

# Retrieve predicted catch
predicted_catch_2 = obj2$report()$predcat
predicted_catch_2
CatDynPred(jfldesvent1112.2P.1.apn.fit, method = 'CG')$Model$Results['Observed.Catch.thou']

```

## Results Comparison

```{r}
#| include: false
#| eval: false
report_2 = report_manual(p = 2,
              method = 'CG',
              opt_result = CG2,
              dates=dates.2P,
              distr = 'normal',
              fleet.name = jflcrusoe0203$Properties$Fleets$Fleet,
              par.tmp = pars.ini.2P)

jfldesvent1112.2P.1.apn.fit$Model$CG$bt.par


report_2$CG$bt.par

```

```{r}
#| output: asis
#| echo: false
#| eval: false
cat_pars_2 = jfldesvent1112.2P.1.apn.fit$Model$CG$bt.par

xtable(data.frame(
                  alpha = c(cat_pars_2$alpha.nasas, exp(fit2$par['logalpha']), exp(CG2['logalpha']) %>% unlist),
                  beta = c(cat_pars_2$beta.nasas, exp(fit2$par['logbeta']), exp(CG2['logbeta'])%>% unlist),
                  k = c(cat_pars_2$k.nasas, exp(fit2$par['logK']), exp(CG2['logK'])%>% unlist),
                  M = c(cat_pars_2$M, exp(fit2$par['logM']), exp(CG2['logM'])%>% unlist),
                  N0 = c(cat_pars_2$N0, exp(fit2$par['logN0']), exp(CG2['logN0'])%>% unlist),
                  SD_Ct = c(cat_pars_2$psi.nasas, exp(fit2$par["logsdCt"]), exp(CG2["logsdCt"])%>% unlist),
                  R1 = c(cat_pars_2$P1.nasas,fit2$par[3],CG2[3]%>% unlist %>% exp),
                  R2 = c(cat_pars_2$P2.nasas,fit2$par[4],CG2[4]%>% unlist %>% exp),

                  row.names = c('CatDyn','RTMB', 'RTMB_CG')) %>% t, digits = 8) %>% 
  print(comment = F,
        sanitize.text.function = function(x)
          {gsub("_", "\\\\_", x)})


                                
 check_1cat_2 = 
catdynexp(x=jflcrusoe0203,                                 
      p=2,
      par=log(c(cat_pars_2$M,
      cat_pars_2$N0,
      cat_pars_2$P1.nasas,
      cat_pars_2$P2.nasas,
      cat_pars_2$k.nasas,
      cat_pars_2$alpha.nasas,
      cat_pars_2$beta.nasas,
      cat_pars_2$psi.nasas)),
      dates=dates.2P,
      distr="normal")

check_2cat_2 = 
catdynexp(x=jflcrusoe0203,                                 
      p=2,
      par=log(c(exp(fit2$par['logM']),
      exp(fit2$par['logN0']),
      fit2$par[3]%>% exp,
      fit2$par[4]%>% exp,
      exp(fit2$par['logK']),
      exp(fit2$par['logalpha']),
      exp(fit2$par['logbeta']),
      exp(fit2$par['logsdCt']))),
      dates=dates.2P,
      distr="normal")

ggplot() + 
  geom_line(aes(x = 1:36,
                y = check_1cat_2$Model$Results$Predicted.Catch.thou)) + 
  geom_line(aes(x = 1:36,
                y = check_2cat_2$Model$Results$Predicted.Catch.thou), col = 'red',
            linetype = 'dashed') + 
  theme_bw() + 
  labs(y = 'catch', title = 'Catdyn (black), RTMB (red)')

```

```{r}
#| eval: false
# tibec.14.22.pg.apn.1.fit.pred.CG$Model$Results['Predicted.Catch.thou']
# catch

pred_lobster = CatDynPred(jfldesvent1112.2P.1.apn.fit, method = 'CG') 

grid.arrange(

ggplot() + 
  geom_line(aes(x = 1:36,
                y = unlist(pred_lobster$Model$Results['Predicted.Catch.thou']))) + 
  geom_line(aes(x = 1:36,
                y = predicted_catch_2), col = 'red') + 
  theme_bw() + 
  labs(y = 'catch', title = 'Catdyn (black), RTMB (red)')
,

ggplot() + 
  geom_line(aes(x = 1:2,
                y = unlist(jfldesvent1112.2P.1.apn.fit$Model$CG$bt.par[3:4])))+ 
  geom_line(aes(x = 1:2,
                y =  fit2$par[1:2]), col = 'red') + 
    geom_line(aes(x = 1:2,
                y =  par$Rt_scaled), col = 'green') + 
  theme_bw()+ 
    labs(y = 'Recruitment', title = 'Catdyn (black), RTMB (red), Starting values (green)'),
ncol=1)

```


# Octopus Example

## CatDyn

```{r}
#| eval: false
cat_df = as.CatDynData(x=df_effort %>%
                         filter(as.numeric(
                           as.character(year_sale)) %in% c(2006:2023)),
                       step="month",
                       fleet.name="MIS+OTB-S",
                       coleff=6,
                       colcat=5,
                       colmbw=9,
                       unitseff="trips",
                       unitscat="kg",
                       unitsmbw="kg",
                       nmult="thou",
                       season.dates=c(as.Date("2006-01-01"),
                                      last_date_of_week(2023, 52)-1))

indice_manual =
  list(
    10,11,12,
    12,12,10,11,12,
    11,10,12,7,10,
    12,11,12,12,10)

for(i in 0:(length(indice_manual)-1)){
  indice_manual[[i+1]] = 12*i + indice_manual[[i+1]]
}

dat = list()
dat$Ct = as.vector(cat_df$Data$`MIS+OTB-S`$obscat.thou)         # observed catch
dat$Et = as.vector(cat_df$Data$`MIS+OTB-S`$obseff.trips)       # effort
dat$u = unlist(indice_manual)                   # recruitment pulse months
nT = length(dat$Ct)
nR = length(dat$u)


I = matrix(0, nrow = nT, ncol = nR)
for (j in 1:nR) {
  I[(dat$u[j]-1):nT, j] <- 1 # -1 foi adicionado para ficar consistente com CatDyn.
}

dat$I = I


par = list(
  logM          = log(0.01),
  logN0_scaled  = log(60000),
  # logRt_scaled = log(rep(50000,18)),
  logRt_scaled = log(c(20000, 100000,20000,            #
                20000, 20000, 20000, 50000,20000,       
                20000, 20000, 20000, 20000, 20000,
                20000, 20000,40000,20000,20000)),
  logK          = log(0.00005),
  logalpha      = log(.85),
  logbeta       = log(.85),
  logsdCt       = log(0.25 * sd(dat$Ct[dat$Ct > 0]))  # consistent with CatDyn
)

##################



distribuicoes = c("gamma", "lognormal","normal","negbin","aplnormal", "apnormal")
optimizadores = c('CG', 'spg', 'BFGS', 'Nelder-Mead')

#first trial
a = Sys.time()
fit_occ =
  trialer(cat_df,
           p = 18,
                M = exp(par$logM),
                N0.ini = exp(par$logN0_scaled),
                P = indice_manual,
                P.ini  = as.list(exp(par$logRt_scaled)),
                k.ini = exp(par$logK),
                alpha.ini = exp(par$logalpha),
                beta.ini  = exp(par$logbeta),
                distr = distribuicoes[2],
                method = optimizadores[1],
                itnmax = 10000,
                disp = list(exp(par$logsdCt)))
b = Sys.time()
b-a


annual_biomass =
  CatDynBSD(fit_occ$fit,
            method = names(fit_occ$fit$Model),
            multi = T,
            mbw.sd = predicos$se.fit) %>% 
  mutate(TimeStep = 216,
         x =seq(2006,2023+11/12,1/12)) 

catch_occ = unlist(CatDynPred(x=fit_occ$fit,method="CG")$Model$Results['Predicted.Catch.thou'])
```

## RTMB

```{r}
#| eval: false
par$logN0_scaled

jnll = function(par) {
  getAll(par, dat)

  # Extract parameters
  Ct     = OBS(Ct)
  Et     = OBS(Et)
  I  =    OBS(I)
  alpha  = exp(logalpha)
  beta   = exp(logbeta)
  k      = exp(logK)
  N0     = exp(logN0_scaled)
  M      = exp(logM)
  sdCt   = exp(logsdCt)
  Rt     = exp(logRt_scaled)

  jnll = 0
  # Initialize predicted catch and biomass


  #comprimento = length(Ct)
nstep <- vector("numeric", nT) * alpha#init vector
mccum = vector("numeric", nT) * alpha
effeff1 = vector("numeric", nT) * alpha
effn1 = vector("numeric", nT) * alpha
predcat = vector("numeric", nT) * alpha

# N0 = exp(logN0)
# M = exp(logM)
# k = exp(logK)
# beta = exp(logbeta)
# alpha = exp(logalpha)

  mccum[1] = 0
  nstep[1] <- N0 * exp(-M)
  for(i in 2:nT){
    mccum[i] = Ct[i-1] + mccum[i-1] * exp(-M)
    nstep[i] = N0 * exp(-M*i) + 
      sum(I[i,] * Rt * exp(-M*(i-(u-1)+1))) -
      mccum[i] * exp(-M/2)
    effeff1 <- Et^(alpha)
    effn1 <- nstep^(beta)
    predcat <- k * (effeff1 * effn1) * exp(-M/2)
  }
  
  # Negative log-likelihood
  jnll = -sum(dnorm(Ct, mean = predcat, sd = sdCt, log = TRUE))
  # if (is.null(Rt)) stop("Rt is NULL — check if Rt_scaled was passed correctly.")
    REPORT(predcat)
  jnll

}



# quick test: do we get a number? This number should be a likelihood.
jnll(par)


obj3= MakeADFun(jnll, par)

# Set bounds
# lower <- list(
#   Rt_scaled = rep(Rt_min, 9),
#   logalpha = -10, logbeta = -10, logK = -10,
#   logN0_scaled = -10, logM = -10, logsdCt = -10
# )
# 
# upper <- list(
#   Rt_scaled = rep(Rt_max, 9),
#   logalpha = 10, logbeta = 10, logK = 10,
#   logN0_scaled = 10, logM = 10, logsdCt = 10
# )

# Run optimizer
fit3 = nlminb(obj3$par, obj3$fn, obj3$gr,
  # lower = unlist(lower),
  # upper = unlist(upper),
  control = list(iter.max = 50000))

# CG7 <- optim(
#   par = obj7$par,
#   fn = obj7$fn,
#   gr = obj7$gr,
#   method = "CG",
#   control = list(maxit = 1000))

# gradient was set to NULL to match CatDyn approach
CG3 = optimx(par = obj3$par,
             fn = obj3$fn,
             gr = NULL,
             method = 'CG',
             output = 'estimate',
             hessian = T,
             itnmax = 50000)

# report from catdyn
fit_occ$fit$Model

# report from RTMB
report_manual(p = 18,
              method = 'CG',
              opt_result = CG3,
              dates=c(1, dat$u, nT),
              distr = 'lognormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par)

# Retrieve predicted catch
predicted_catch_3 = obj3$report()$predcat
```

```{r}
#| eval: false
report_3 = report_manual(p = 18,
              method = 'CG',
              opt_result = CG3,
              dates=c(1, dat$u, nT),
              distr = 'lognormal',
              fleet.name = cat_df$Properties$Fleets$Fleet,
              par.tmp = par)

fit_occ$fit$Model$CG$bt.par


report_3$CG$bt.par
  
```

```{r}
#| output: asis
#| echo: false
#| eval: false
cat_pars_3 = fit_occ$fit$Model$CG$bt.par

xtable(data.frame(
                  alpha = c(cat_pars_3$`alpha.MIS+OTB-S`, exp(fit3$par['logalpha']), exp(CG3['logalpha']) %>% unlist),
                  beta = c(cat_pars_3$`beta.MIS+OTB-S`, exp(fit3$par['logbeta']), exp(CG3['logbeta'])%>% unlist),
                  k = c(cat_pars_3$`k.MIS+OTB-S`, exp(fit3$par['logK']), exp(CG3['logK'])%>% unlist),
                  M = c(cat_pars_3$M, exp(fit3$par['logM']), exp(CG3['logM'])%>% unlist),
                  N0 = c(cat_pars_3$N0, exp(fit3$par['logN0_scaled']), exp(CG3['logN0_scaled'])%>% unlist),
                  SD_Ct = c(cat_pars_3$`psi.MIS+OTB-S`, exp(fit3$par["logsdCt"]), exp(CG3["logsdCt"])%>% unlist),
                  R1 = c(cat_pars_3$`P1.MIS+OTB-S`,fit3$par[1],CG3[1]%>% unlist %>% exp),
                  R2 = c(cat_pars_3$`P2.MIS+OTB-S`,fit3$par[2],CG3[2]%>% unlist %>% exp),

                  row.names = c('CatDyn','RTMB', 'RTMB_CG')) %>% t, digits = 8) %>% 
  print(comment = F,
        sanitize.text.function = function(x)
          {gsub("_", "\\\\_", x)})
```

